import { each as asyncEach } from 'async';
import { spawnSync } from 'child_process';
import commonFindJavaHome, { flatten } from './common';
/**
 * Find Java on Windows by checking registry keys and PATH
 */
export default function windowsFindJavaHome() {
    return Promise.all([commonFindJavaHome(), checkRegistryKeys()])
        .then(res => {
        // combine the results:
        return {
            homes: res[0].concat(res[1].homes),
            executableExtension: res[1].executableExtension
        };
    });
}
function checkRegistryKeys() {
    // Windows: JDK path is in either of the following registry keys:
    // - HKLM\Software\JavaSoft\Java Development Kit\1.[version] [JDK arch == OS arch]
    // - HKLM\Software\Wow6432Node\JavaSoft\Java Development Kit\1.[version] [32-bit JDK Arch, 64-bit OS arch]
    // TODO: Get a proper listing of all JDKs at these locations.
    const keysToCheck = [
        `HKLM\\SOFTWARE\\JavaSoft\\JDK`,
        `HKLM\\SOFTWARE\\JavaSoft\\Java Development Kit`,
        `HKLM\\SOFTWARE\\JavaSoft\\Java Runtime Environment`,
        `HKLM\\SOFTWARE\\Wow6432Node\\JavaSoft\\JDK`,
        `HKLM\\SOFTWARE\\Wow6432Node\\JavaSoft\\Java Development Kit`,
        `HKLM\\SOFTWARE\\Wow6432Node\\JavaSoft\\Java Runtime Environment`
    ];
    return Promise.all(keysToCheck.map(checkRegistry))
        .then(flatten)
        .then(homes => {
        return {
            homes: homes,
            executableExtension: 'exe'
        };
    });
}
function checkRegistry(key) {
    return new Promise(resolve => {
        getRegistryKey(key, (err, values) => {
            if (err) {
                resolve([]);
            }
            else {
                const homes = flatten(Object.keys(values)
                    .map((value) => {
                    const keyInfo = values[value];
                    if (typeof (keyInfo) === 'object' && keyInfo !== null) {
                        // subkey.
                        const javaHome = keyInfo.JavaHome;
                        if (typeof (javaHome) === "string") {
                            // we wrap the results in arrays such that we can return an empty array on error
                            // using `flatten`, we recover the one dimensional list of java homes
                            // returning null on error and filter out null values leads to typing issues as 
                            // the type system apparently cannot prove non-nullness of all elements
                            return [javaHome];
                        }
                    }
                    return [];
                }));
                resolve(homes);
            }
        });
    });
}
const ITEM_PATTERN = /^([a-zA-Z0-9_\s\\-]+)\s(REG_SZ|REG_MULTI_SZ|REG_EXPAND_SZ|REG_DWORD|REG_QWORD|REG_BINARY|REG_NONE)\s+([^\s].*)$/;
/**
 * Retrieves the given registry key using the REG command line utility.
 * Returns an error if it fails, or the key as a dictionary if it succeeds.
 * Inspired by node-winreg, but rewritten here due to a bug in that module.
 * https://github.com/fresc81/node-winreg
 */
function getRegistryKey(key, cb) {
    const args = ['QUERY', key];
    try {
        const proc = spawnSync('REG', args, {
            cwd: undefined,
            env: process.env,
            stdio: ['ignore', 'pipe', 'ignore']
        });
        if (proc.status !== 0) {
            return cb(new Error(`REG process exited with code ${proc.status}:\n${proc.stderr.toString()}\n${proc.stdout.toString()}`));
        }
        // Success
        const lines = proc.stdout.toString().split('\n');
        let lineNumber = 0;
        const items = [];
        const rv = {};
        lines.forEach((line, idx) => {
            lines[idx] = line.trim();
            if (lines[idx].length > 0) {
                if (lineNumber !== 0) {
                    items.push(lines[idx]);
                }
                ++lineNumber;
            }
        });
        asyncEach(items, (item, asyncCb) => {
            const match = ITEM_PATTERN.exec(item);
            if (match) {
                // rv[valName] = value;
                // Second item is the type; we don't care about that.
                rv[match[1].trim()] = match[3];
                asyncCb();
            }
            else if (item.slice(0, 4) === "HKEY") {
                // It's a HKEY_[etc]\ path. Recursively expand!
                getRegistryKey(item.trim(), (err, vals) => {
                    if (!err) {
                        rv[item.slice(item.lastIndexOf('\\') + 1)] = vals;
                    }
                    asyncCb(err);
                });
            }
            else {
                asyncCb();
            }
        }, (err) => {
            cb(err, rv);
        });
    }
    catch (e) {
        cb(new Error(`exception while getting registry key ${key}: ${e}`));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2luMzIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi90cy9saWIvcGxhdGZvcm1zL3dpbjMyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxJQUFJLElBQUksU0FBUyxFQUFDLE1BQU0sT0FBTyxDQUFDO0FBQ3hDLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFeEMsT0FBTyxrQkFBa0IsRUFBRSxFQUFDLE9BQU8sRUFBQyxNQUFNLFVBQVUsQ0FBQztBQU1yRDs7R0FFRztBQUNILE1BQU0sQ0FBQyxPQUFPLFVBQVUsbUJBQW1CO0lBQ3pDLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLGtCQUFrQixFQUFFLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDO1NBQzVELElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUNWLHVCQUF1QjtRQUN2QixPQUFPO1lBQ0wsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztZQUNsQyxtQkFBbUIsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQW1CO1NBQ2hELENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNQLENBQUM7QUFFRCxTQUFTLGlCQUFpQjtJQUN4QixpRUFBaUU7SUFDakUsa0ZBQWtGO0lBQ2xGLDBHQUEwRztJQUUxRyw2REFBNkQ7SUFDN0QsTUFBTSxXQUFXLEdBQWE7UUFDNUIsK0JBQStCO1FBQy9CLGdEQUFnRDtRQUNoRCxvREFBb0Q7UUFDcEQsNENBQTRDO1FBQzVDLDZEQUE2RDtRQUM3RCxpRUFBaUU7S0FDbEUsQ0FBQztJQUVGLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQy9DLElBQUksQ0FBQyxPQUFPLENBQUM7U0FDYixJQUFJLENBQUMs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Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtlYWNoIGFzIGFzeW5jRWFjaH0gZnJvbSAnYXN5bmMnO1xuaW1wb3J0IHtzcGF3blN5bmN9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHtJTG9jYXRlSmF2YUhvbWVSZXN1bHR9IGZyb20gJy4uL2ludGVyZmFjZXMnO1xuaW1wb3J0IGNvbW1vbkZpbmRKYXZhSG9tZSwge2ZsYXR0ZW59IGZyb20gJy4vY29tbW9uJztcblxuaW50ZXJmYWNlIElLZXlJbmZvIHtcbiAgW3ZhbE5hbWU6IHN0cmluZ106IHN0cmluZyB8IElLZXlJbmZvXG59XG5cbi8qKlxuICogRmluZCBKYXZhIG9uIFdpbmRvd3MgYnkgY2hlY2tpbmcgcmVnaXN0cnkga2V5cyBhbmQgUEFUSFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3aW5kb3dzRmluZEphdmFIb21lKCk6IFByb21pc2U8SUxvY2F0ZUphdmFIb21lUmVzdWx0PiB7XG4gIHJldHVybiBQcm9taXNlLmFsbChbY29tbW9uRmluZEphdmFIb21lKCksIGNoZWNrUmVnaXN0cnlLZXlzKCldKVxuICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAvLyBjb21iaW5lIHRoZSByZXN1bHRzOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaG9tZXM6IHJlc1swXS5jb25jYXQocmVzWzFdLmhvbWVzKSxcbiAgICAgICAgZXhlY3V0YWJsZUV4dGVuc2lvbjogcmVzWzFdLmV4ZWN1dGFibGVFeHRlbnNpb25cbiAgICAgIH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUmVnaXN0cnlLZXlzKCk6IFByb21pc2U8SUxvY2F0ZUphdmFIb21lUmVzdWx0PiB7XG4gIC8vIFdpbmRvd3M6IEpESyBwYXRoIGlzIGluIGVpdGhlciBvZiB0aGUgZm9sbG93aW5nIHJlZ2lzdHJ5IGtleXM6XG4gIC8vIC0gSEtMTVxcU29mdHdhcmVcXEphdmFTb2Z0XFxKYXZhIERldmVsb3BtZW50IEtpdFxcMS5bdmVyc2lvbl0gW0pESyBhcmNoID09IE9TIGFyY2hdXG4gIC8vIC0gSEtMTVxcU29mdHdhcmVcXFdvdzY0MzJOb2RlXFxKYXZhU29mdFxcSmF2YSBEZXZlbG9wbWVudCBLaXRcXDEuW3ZlcnNpb25dIFszMi1iaXQgSkRLIEFyY2gsIDY0LWJpdCBPUyBhcmNoXVxuXG4gIC8vIFRPRE86IEdldCBhIHByb3BlciBsaXN0aW5nIG9mIGFsbCBKREtzIGF0IHRoZXNlIGxvY2F0aW9ucy5cbiAgY29uc3Qga2V5c1RvQ2hlY2s6IHN0cmluZ1tdID0gW1xuICAgIGBIS0xNXFxcXFNPRlRXQVJFXFxcXEphdmFTb2Z0XFxcXEpES2AsXG4gICAgYEhLTE1cXFxcU09GVFdBUkVcXFxcSmF2YVNvZnRcXFxcSmF2YSBEZXZlbG9wbWVudCBLaXRgLFxuICAgIGBIS0xNXFxcXFNPRlRXQVJFXFxcXEphdmFTb2Z0XFxcXEphdmEgUnVudGltZSBFbnZpcm9ubWVudGAsXG4gICAgYEhLTE1cXFxcU09GVFdBUkVcXFxcV293NjQzMk5vZGVcXFxcSmF2YVNvZnRcXFxcSkRLYCxcbiAgICBgSEtMTVxcXFxTT0ZUV0FSRVxcXFxXb3c2NDMyTm9kZVxcXFxKYXZhU29mdFxcXFxKYXZhIERldmVsb3BtZW50IEtpdGAsXG4gICAgYEhLTE1cXFxcU09GVFdBUkVcXFxcV293NjQzMk5vZGVcXFxcSmF2YVNvZnRcXFxcSmF2YSBSdW50aW1lIEVudmlyb25tZW50YFxuICBdO1xuXG4gIHJldHVybiBQcm9taXNlLmFsbChrZXlzVG9DaGVjay5tYXAoY2hlY2tSZWdpc3RyeSkpXG4gICAgLnRoZW4oZmxhdHRlbilcbiAgICAudGhlbihob21lcyA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBob21lczogaG9tZXMsIFxuICAgICAgICBleGVjdXRhYmxlRXh0ZW5zaW9uOiAnZXhlJ1xuICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY2hlY2tSZWdpc3RyeShrZXk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGdldFJlZ2lzdHJ5S2V5KGtleSwgKGVycj86IEVycm9yIHwgbnVsbCwgdmFsdWVzPzogSUtleUluZm8pID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBob21lczogc3RyaW5nW10gPSBmbGF0dGVuKE9iamVjdC5rZXlzKHZhbHVlcyEpXG4gICAgICAgICAgLm1hcCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleUluZm8gPSB2YWx1ZXMhW3ZhbHVlXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yoa2V5SW5mbykgPT09ICdvYmplY3QnICYmIGtleUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gc3Via2V5LlxuICAgICAgICAgICAgICBjb25zdCBqYXZhSG9tZSA9IGtleUluZm8uSmF2YUhvbWU7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YoamF2YUhvbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Ugd3JhcCB0aGUgcmVzdWx0cyBpbiBhcnJheXMgc3VjaCB0aGF0IHdlIGNhbiByZXR1cm4gYW4gZW1wdHkgYXJyYXkgb24gZXJyb3JcbiAgICAgICAgICAgICAgICAvLyB1c2luZyBgZmxhdHRlbmAsIHdlIHJlY292ZXIgdGhlIG9uZSBkaW1lbnNpb25hbCBsaXN0IG9mIGphdmEgaG9tZXNcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5pbmcgbnVsbCBvbiBlcnJvciBhbmQgZmlsdGVyIG91dCBudWxsIHZhbHVlcyBsZWFkcyB0byB0eXBpbmcgaXNzdWVzIGFzIFxuICAgICAgICAgICAgICAgIC8vIHRoZSB0eXBlIHN5c3RlbSBhcHBhcmVudGx5IGNhbm5vdCBwcm92ZSBub24tbnVsbG5lc3Mgb2YgYWxsIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtqYXZhSG9tZV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIHJlc29sdmUoaG9tZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuY29uc3QgSVRFTV9QQVRURVJOID0gL14oW2EtekEtWjAtOV9cXHNcXFxcLV0rKVxccyhSRUdfU1p8UkVHX01VTFRJX1NafFJFR19FWFBBTkRfU1p8UkVHX0RXT1JEfFJFR19RV09SRHxSRUdfQklOQVJZfFJFR19OT05FKVxccysoW15cXHNdLiopJC87XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBnaXZlbiByZWdpc3RyeSBrZXkgdXNpbmcgdGhlIFJFRyBjb21tYW5kIGxpbmUgdXRpbGl0eS5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgZmFpbHMsIG9yIHRoZSBrZXkgYXMgYSBkaWN0aW9uYXJ5IGlmIGl0IHN1Y2NlZWRzLlxuICogSW5zcGlyZWQgYnkgbm9kZS13aW5yZWcsIGJ1dCByZXdyaXR0ZW4gaGVyZSBkdWUgdG8gYSBidWcgaW4gdGhhdCBtb2R1bGUuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZnJlc2M4MS9ub2RlLXdpbnJlZ1xuICovXG5mdW5jdGlvbiBnZXRSZWdpc3RyeUtleShrZXk6IHN0cmluZywgY2I6IChlcnI/OiBFcnJvciB8IG51bGwsIHZhbHVlcz86IElLZXlJbmZvKSA9PiB2b2lkKSB7XG4gIGNvbnN0IGFyZ3MgPSBbJ1FVRVJZJywga2V5XTtcbiAgdHJ5IHtcbiAgICBjb25zdCBwcm9jID0gc3Bhd25TeW5jKCdSRUcnLCBhcmdzLCB7XG4gICAgICBjd2Q6IHVuZGVmaW5lZCxcbiAgICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gICAgICBzdGRpbzogWydpZ25vcmUnLCAncGlwZScsICdpZ25vcmUnXVxuICAgIH0pO1xuICAgIGlmIChwcm9jLnN0YXR1cyAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgUkVHIHByb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAke3Byb2Muc3RhdHVzfTpcXG4ke3Byb2Muc3RkZXJyLnRvU3RyaW5nKCl9XFxuJHtwcm9jLnN0ZG91dC50b1N0cmluZygpfWApKTtcbiAgICB9XG4gICAgLy8gU3VjY2Vzc1xuICAgIGNvbnN0IGxpbmVzID0gcHJvYy5zdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgbGV0IGxpbmVOdW1iZXIgPSAwO1xuICAgIGNvbnN0IGl0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHJ2OiBJS2V5SW5mbyA9IHt9O1xuXG4gICAgbGluZXMuZm9yRWFjaCgobGluZTogc3RyaW5nLCBpZHg6IG51bWJlcikgPT4ge1xuICAgICAgbGluZXNbaWR4XSA9IGxpbmUudHJpbSgpO1xuICAgICAgaWYgKGxpbmVzW2lkeF0ubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAobGluZU51bWJlciAhPT0gMCkge1xuICAgICAgICAgIGl0ZW1zLnB1c2gobGluZXNbaWR4XSk7XG4gICAgICAgIH1cbiAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXN5bmNFYWNoKGl0ZW1zLCAoaXRlbTogc3RyaW5nLCBhc3luY0NiOiAoZXJyPzogRXJyb3IgfCBudWxsKSA9PiB2b2lkKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IElURU1fUEFUVEVSTi5leGVjKGl0ZW0pO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIC8vIHJ2W3ZhbE5hbWVdID0gdmFsdWU7XG4gICAgICAgIC8vIFNlY29uZCBpdGVtIGlzIHRoZSB0eXBlOyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoYXQuXG4gICAgICAgIHJ2W21hdGNoWzFdLnRyaW0oKV0gPSBtYXRjaFszXTtcbiAgICAgICAgYXN5bmNDYigpO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLnNsaWNlKDAsIDQpID09PSBcIkhLRVlcIikge1xuICAgICAgICAvLyBJdCdzIGEgSEtFWV9bZXRjXVxcIHBhdGguIFJlY3Vyc2l2ZWx5IGV4cGFuZCFcbiAgICAgICAgZ2V0UmVnaXN0cnlLZXkoaXRlbS50cmltKCksIChlcnIsIHZhbHMpID0+IHtcbiAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgcnZbaXRlbS5zbGljZShpdGVtLmxhc3RJbmRleE9mKCdcXFxcJykgKyAxKV0gPSB2YWxzITtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXN5bmNDYihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzeW5jQ2IoKTtcbiAgICAgIH1cbiAgICB9LCAoZXJyPzogRXJyb3IgfCBudWxsKSA9PiB7XG4gICAgICBjYihlcnIsIHJ2KTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNiKG5ldyBFcnJvcihgZXhjZXB0aW9uIHdoaWxlIGdldHRpbmcgcmVnaXN0cnkga2V5ICR7a2V5fTogJHtlfWApKTtcbiAgfVxufVxuIl19