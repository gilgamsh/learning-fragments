"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const async_1 = require("async");
const child_process_1 = require("child_process");
const common_1 = require("./common");
/**
 * Find Java on Windows by checking registry keys and PATH
 */
function windowsFindJavaHome() {
    return Promise.all([(0, common_1.default)(), checkRegistryKeys()])
        .then(res => {
        // combine the results:
        return {
            homes: res[0].concat(res[1].homes),
            executableExtension: res[1].executableExtension
        };
    });
}
exports.default = windowsFindJavaHome;
function checkRegistryKeys() {
    // Windows: JDK path is in either of the following registry keys:
    // - HKLM\Software\JavaSoft\Java Development Kit\1.[version] [JDK arch == OS arch]
    // - HKLM\Software\Wow6432Node\JavaSoft\Java Development Kit\1.[version] [32-bit JDK Arch, 64-bit OS arch]
    // TODO: Get a proper listing of all JDKs at these locations.
    const keysToCheck = [
        `HKLM\\SOFTWARE\\JavaSoft\\JDK`,
        `HKLM\\SOFTWARE\\JavaSoft\\Java Development Kit`,
        `HKLM\\SOFTWARE\\JavaSoft\\Java Runtime Environment`,
        `HKLM\\SOFTWARE\\Wow6432Node\\JavaSoft\\JDK`,
        `HKLM\\SOFTWARE\\Wow6432Node\\JavaSoft\\Java Development Kit`,
        `HKLM\\SOFTWARE\\Wow6432Node\\JavaSoft\\Java Runtime Environment`
    ];
    return Promise.all(keysToCheck.map(checkRegistry))
        .then(common_1.flatten)
        .then(homes => {
        return {
            homes: homes,
            executableExtension: 'exe'
        };
    });
}
function checkRegistry(key) {
    return new Promise(resolve => {
        getRegistryKey(key, (err, values) => {
            if (err) {
                resolve([]);
            }
            else {
                const homes = (0, common_1.flatten)(Object.keys(values)
                    .map((value) => {
                    const keyInfo = values[value];
                    if (typeof (keyInfo) === 'object' && keyInfo !== null) {
                        // subkey.
                        const javaHome = keyInfo.JavaHome;
                        if (typeof (javaHome) === "string") {
                            // we wrap the results in arrays such that we can return an empty array on error
                            // using `flatten`, we recover the one dimensional list of java homes
                            // returning null on error and filter out null values leads to typing issues as 
                            // the type system apparently cannot prove non-nullness of all elements
                            return [javaHome];
                        }
                    }
                    return [];
                }));
                resolve(homes);
            }
        });
    });
}
const ITEM_PATTERN = /^([a-zA-Z0-9_\s\\-]+)\s(REG_SZ|REG_MULTI_SZ|REG_EXPAND_SZ|REG_DWORD|REG_QWORD|REG_BINARY|REG_NONE)\s+([^\s].*)$/;
/**
 * Retrieves the given registry key using the REG command line utility.
 * Returns an error if it fails, or the key as a dictionary if it succeeds.
 * Inspired by node-winreg, but rewritten here due to a bug in that module.
 * https://github.com/fresc81/node-winreg
 */
function getRegistryKey(key, cb) {
    const args = ['QUERY', key];
    try {
        const proc = (0, child_process_1.spawnSync)('REG', args, {
            cwd: undefined,
            env: process.env,
            stdio: ['ignore', 'pipe', 'ignore']
        });
        if (proc.status !== 0) {
            return cb(new Error(`REG process exited with code ${proc.status}:\n${proc.stderr.toString()}\n${proc.stdout.toString()}`));
        }
        // Success
        const lines = proc.stdout.toString().split('\n');
        let lineNumber = 0;
        const items = [];
        const rv = {};
        lines.forEach((line, idx) => {
            lines[idx] = line.trim();
            if (lines[idx].length > 0) {
                if (lineNumber !== 0) {
                    items.push(lines[idx]);
                }
                ++lineNumber;
            }
        });
        (0, async_1.each)(items, (item, asyncCb) => {
            const match = ITEM_PATTERN.exec(item);
            if (match) {
                // rv[valName] = value;
                // Second item is the type; we don't care about that.
                rv[match[1].trim()] = match[3];
                asyncCb();
            }
            else if (item.slice(0, 4) === "HKEY") {
                // It's a HKEY_[etc]\ path. Recursively expand!
                getRegistryKey(item.trim(), (err, vals) => {
                    if (!err) {
                        rv[item.slice(item.lastIndexOf('\\') + 1)] = vals;
                    }
                    asyncCb(err);
                });
            }
            else {
                asyncCb();
            }
        }, (err) => {
            cb(err, rv);
        });
    }
    catch (e) {
        cb(new Error(`exception while getting registry key ${key}: ${e}`));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2luMzIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi90cy9saWIvcGxhdGZvcm1zL3dpbjMyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsaUNBQXdDO0FBQ3hDLGlEQUF3QztBQUV4QyxxQ0FBcUQ7QUFNckQ7O0dBRUc7QUFDSCxTQUF3QixtQkFBbUI7SUFDekMsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBQSxnQkFBa0IsR0FBRSxFQUFFLGlCQUFpQixFQUFFLENBQUMsQ0FBQztTQUM1RCxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDVix1QkFBdUI7UUFDdkIsT0FBTztZQUNMLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7WUFDbEMsbUJBQW1CLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLG1CQUFtQjtTQUNoRCxDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDO0FBVEQsc0NBU0M7QUFFRCxTQUFTLGlCQUFpQjtJQUN4QixpRUFBaUU7SUFDakUsa0ZBQWtGO0lBQ2xGLDBHQUEwRztJQUUxRyw2REFBNkQ7SUFDN0QsTUFBTSxXQUFXLEdBQWE7UUFDNUIsK0JBQStCO1FBQy9CLGdEQUFnRDtRQUNoRCxvREFBb0Q7UUFDcEQsNENBQTRDO1FBQzVDLDZEQUE2RDtRQUM3RCxpRUFBaUU7S0FDbEUsQ0FBQztJQUVGLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQy9DLElBQUksQ0FBQyxnQkFBTyxDQUFDO1NBQ2IsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ1osT0FBTztZQUNMLEtBQUssRUFBRSxLQUFLO1lBQ1osbUJBQW1CLEVBQUUsS0FBSztTQUMzQixDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7QUFD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cUMsRUFBRSxFQUFFO1lBQ3ZFLE1BQU0sS0FBSyxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdEMsSUFBSSxLQUFLLEVBQUU7Z0JBQ1QsdUJBQXVCO2dCQUN2QixxREFBcUQ7Z0JBQ3JELEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQy9CLE9BQU8sRUFBRSxDQUFDO2FBQ1g7aUJBQU0sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxNQUFNLEVBQUU7Z0JBQ3RDLCtDQUErQztnQkFDL0MsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRTtvQkFDeEMsSUFBSSxDQUFDLEdBQUcsRUFBRTt3QkFDUixFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSyxDQUFDO3FCQUNwRDtvQkFDRCxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ2YsQ0FBQyxDQUFDLENBQUM7YUFDSjtpQkFBTTtnQkFDTCxPQUFPLEVBQUUsQ0FBQzthQUNYO1FBQ0gsQ0FBQyxFQUFFLENBQUMsR0FBa0IsRUFBRSxFQUFFO1lBQ3hCLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDZCxDQUFDLENBQUMsQ0FBQztLQUNKO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixFQUFFLENBQUMsSUFBSSxLQUFLLENBQUMsd0NBQXdDLEdBQUcsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDcEU7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtlYWNoIGFzIGFzeW5jRWFjaH0gZnJvbSAnYXN5bmMnO1xuaW1wb3J0IHtzcGF3blN5bmN9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHtJTG9jYXRlSmF2YUhvbWVSZXN1bHR9IGZyb20gJy4uL2ludGVyZmFjZXMnO1xuaW1wb3J0IGNvbW1vbkZpbmRKYXZhSG9tZSwge2ZsYXR0ZW59IGZyb20gJy4vY29tbW9uJztcblxuaW50ZXJmYWNlIElLZXlJbmZvIHtcbiAgW3ZhbE5hbWU6IHN0cmluZ106IHN0cmluZyB8IElLZXlJbmZvXG59XG5cbi8qKlxuICogRmluZCBKYXZhIG9uIFdpbmRvd3MgYnkgY2hlY2tpbmcgcmVnaXN0cnkga2V5cyBhbmQgUEFUSFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3aW5kb3dzRmluZEphdmFIb21lKCk6IFByb21pc2U8SUxvY2F0ZUphdmFIb21lUmVzdWx0PiB7XG4gIHJldHVybiBQcm9taXNlLmFsbChbY29tbW9uRmluZEphdmFIb21lKCksIGNoZWNrUmVnaXN0cnlLZXlzKCldKVxuICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAvLyBjb21iaW5lIHRoZSByZXN1bHRzOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaG9tZXM6IHJlc1swXS5jb25jYXQocmVzWzFdLmhvbWVzKSxcbiAgICAgICAgZXhlY3V0YWJsZUV4dGVuc2lvbjogcmVzWzFdLmV4ZWN1dGFibGVFeHRlbnNpb25cbiAgICAgIH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUmVnaXN0cnlLZXlzKCk6IFByb21pc2U8SUxvY2F0ZUphdmFIb21lUmVzdWx0PiB7XG4gIC8vIFdpbmRvd3M6IEpESyBwYXRoIGlzIGluIGVpdGhlciBvZiB0aGUgZm9sbG93aW5nIHJlZ2lzdHJ5IGtleXM6XG4gIC8vIC0gSEtMTVxcU29mdHdhcmVcXEphdmFTb2Z0XFxKYXZhIERldmVsb3BtZW50IEtpdFxcMS5bdmVyc2lvbl0gW0pESyBhcmNoID09IE9TIGFyY2hdXG4gIC8vIC0gSEtMTVxcU29mdHdhcmVcXFdvdzY0MzJOb2RlXFxKYXZhU29mdFxcSmF2YSBEZXZlbG9wbWVudCBLaXRcXDEuW3ZlcnNpb25dIFszMi1iaXQgSkRLIEFyY2gsIDY0LWJpdCBPUyBhcmNoXVxuXG4gIC8vIFRPRE86IEdldCBhIHByb3BlciBsaXN0aW5nIG9mIGFsbCBKREtzIGF0IHRoZXNlIGxvY2F0aW9ucy5cbiAgY29uc3Qga2V5c1RvQ2hlY2s6IHN0cmluZ1tdID0gW1xuICAgIGBIS0xNXFxcXFNPRlRXQVJFXFxcXEphdmFTb2Z0XFxcXEpES2AsXG4gICAgYEhLTE1cXFxcU09GVFdBUkVcXFxcSmF2YVNvZnRcXFxcSmF2YSBEZXZlbG9wbWVudCBLaXRgLFxuICAgIGBIS0xNXFxcXFNPRlRXQVJFXFxcXEphdmFTb2Z0XFxcXEphdmEgUnVudGltZSBFbnZpcm9ubWVudGAsXG4gICAgYEhLTE1cXFxcU09GVFdBUkVcXFxcV293NjQzMk5vZGVcXFxcSmF2YVNvZnRcXFxcSkRLYCxcbiAgICBgSEtMTVxcXFxTT0ZUV0FSRVxcXFxXb3c2NDMyTm9kZVxcXFxKYXZhU29mdFxcXFxKYXZhIERldmVsb3BtZW50IEtpdGAsXG4gICAgYEhLTE1cXFxcU09GVFdBUkVcXFxcV293NjQzMk5vZGVcXFxcSmF2YVNvZnRcXFxcSmF2YSBSdW50aW1lIEVudmlyb25tZW50YFxuICBdO1xuXG4gIHJldHVybiBQcm9taXNlLmFsbChrZXlzVG9DaGVjay5tYXAoY2hlY2tSZWdpc3RyeSkpXG4gICAgLnRoZW4oZmxhdHRlbilcbiAgICAudGhlbihob21lcyA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBob21lczogaG9tZXMsIFxuICAgICAgICBleGVjdXRhYmxlRXh0ZW5zaW9uOiAnZXhlJ1xuICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY2hlY2tSZWdpc3RyeShrZXk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGdldFJlZ2lzdHJ5S2V5KGtleSwgKGVycj86IEVycm9yIHwgbnVsbCwgdmFsdWVzPzogSUtleUluZm8pID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBob21lczogc3RyaW5nW10gPSBmbGF0dGVuKE9iamVjdC5rZXlzKHZhbHVlcyEpXG4gICAgICAgICAgLm1hcCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleUluZm8gPSB2YWx1ZXMhW3ZhbHVlXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yoa2V5SW5mbykgPT09ICdvYmplY3QnICYmIGtleUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gc3Via2V5LlxuICAgICAgICAgICAgICBjb25zdCBqYXZhSG9tZSA9IGtleUluZm8uSmF2YUhvbWU7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YoamF2YUhvbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Ugd3JhcCB0aGUgcmVzdWx0cyBpbiBhcnJheXMgc3VjaCB0aGF0IHdlIGNhbiByZXR1cm4gYW4gZW1wdHkgYXJyYXkgb24gZXJyb3JcbiAgICAgICAgICAgICAgICAvLyB1c2luZyBgZmxhdHRlbmAsIHdlIHJlY292ZXIgdGhlIG9uZSBkaW1lbnNpb25hbCBsaXN0IG9mIGphdmEgaG9tZXNcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5pbmcgbnVsbCBvbiBlcnJvciBhbmQgZmlsdGVyIG91dCBudWxsIHZhbHVlcyBsZWFkcyB0byB0eXBpbmcgaXNzdWVzIGFzIFxuICAgICAgICAgICAgICAgIC8vIHRoZSB0eXBlIHN5c3RlbSBhcHBhcmVudGx5IGNhbm5vdCBwcm92ZSBub24tbnVsbG5lc3Mgb2YgYWxsIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtqYXZhSG9tZV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIHJlc29sdmUoaG9tZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuY29uc3QgSVRFTV9QQVRURVJOID0gL14oW2EtekEtWjAtOV9cXHNcXFxcLV0rKVxccyhSRUdfU1p8UkVHX01VTFRJX1NafFJFR19FWFBBTkRfU1p8UkVHX0RXT1JEfFJFR19RV09SRHxSRUdfQklOQVJZfFJFR19OT05FKVxccysoW15cXHNdLiopJC87XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBnaXZlbiByZWdpc3RyeSBrZXkgdXNpbmcgdGhlIFJFRyBjb21tYW5kIGxpbmUgdXRpbGl0eS5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgZmFpbHMsIG9yIHRoZSBrZXkgYXMgYSBkaWN0aW9uYXJ5IGlmIGl0IHN1Y2NlZWRzLlxuICogSW5zcGlyZWQgYnkgbm9kZS13aW5yZWcsIGJ1dCByZXdyaXR0ZW4gaGVyZSBkdWUgdG8gYSBidWcgaW4gdGhhdCBtb2R1bGUuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZnJlc2M4MS9ub2RlLXdpbnJlZ1xuICovXG5mdW5jdGlvbiBnZXRSZWdpc3RyeUtleShrZXk6IHN0cmluZywgY2I6IChlcnI/OiBFcnJvciB8IG51bGwsIHZhbHVlcz86IElLZXlJbmZvKSA9PiB2b2lkKSB7XG4gIGNvbnN0IGFyZ3MgPSBbJ1FVRVJZJywga2V5XTtcbiAgdHJ5IHtcbiAgICBjb25zdCBwcm9jID0gc3Bhd25TeW5jKCdSRUcnLCBhcmdzLCB7XG4gICAgICBjd2Q6IHVuZGVmaW5lZCxcbiAgICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gICAgICBzdGRpbzogWydpZ25vcmUnLCAncGlwZScsICdpZ25vcmUnXVxuICAgIH0pO1xuICAgIGlmIChwcm9jLnN0YXR1cyAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgUkVHIHByb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAke3Byb2Muc3RhdHVzfTpcXG4ke3Byb2Muc3RkZXJyLnRvU3RyaW5nKCl9XFxuJHtwcm9jLnN0ZG91dC50b1N0cmluZygpfWApKTtcbiAgICB9XG4gICAgLy8gU3VjY2Vzc1xuICAgIGNvbnN0IGxpbmVzID0gcHJvYy5zdGRvdXQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJyk7XG4gICAgbGV0IGxpbmVOdW1iZXIgPSAwO1xuICAgIGNvbnN0IGl0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHJ2OiBJS2V5SW5mbyA9IHt9O1xuXG4gICAgbGluZXMuZm9yRWFjaCgobGluZTogc3RyaW5nLCBpZHg6IG51bWJlcikgPT4ge1xuICAgICAgbGluZXNbaWR4XSA9IGxpbmUudHJpbSgpO1xuICAgICAgaWYgKGxpbmVzW2lkeF0ubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAobGluZU51bWJlciAhPT0gMCkge1xuICAgICAgICAgIGl0ZW1zLnB1c2gobGluZXNbaWR4XSk7XG4gICAgICAgIH1cbiAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXN5bmNFYWNoKGl0ZW1zLCAoaXRlbTogc3RyaW5nLCBhc3luY0NiOiAoZXJyPzogRXJyb3IgfCBudWxsKSA9PiB2b2lkKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IElURU1fUEFUVEVSTi5leGVjKGl0ZW0pO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIC8vIHJ2W3ZhbE5hbWVdID0gdmFsdWU7XG4gICAgICAgIC8vIFNlY29uZCBpdGVtIGlzIHRoZSB0eXBlOyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoYXQuXG4gICAgICAgIHJ2W21hdGNoWzFdLnRyaW0oKV0gPSBtYXRjaFszXTtcbiAgICAgICAgYXN5bmNDYigpO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLnNsaWNlKDAsIDQpID09PSBcIkhLRVlcIikge1xuICAgICAgICAvLyBJdCdzIGEgSEtFWV9bZXRjXVxcIHBhdGguIFJlY3Vyc2l2ZWx5IGV4cGFuZCFcbiAgICAgICAgZ2V0UmVnaXN0cnlLZXkoaXRlbS50cmltKCksIChlcnIsIHZhbHMpID0+IHtcbiAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgcnZbaXRlbS5zbGljZShpdGVtLmxhc3RJbmRleE9mKCdcXFxcJykgKyAxKV0gPSB2YWxzITtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXN5bmNDYihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzeW5jQ2IoKTtcbiAgICAgIH1cbiAgICB9LCAoZXJyPzogRXJyb3IgfCBudWxsKSA9PiB7XG4gICAgICBjYihlcnIsIHJ2KTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNiKG5ldyBFcnJvcihgZXhjZXB0aW9uIHdoaWxlIGdldHRpbmcgcmVnaXN0cnkga2V5ICR7a2V5fTogJHtlfWApKTtcbiAgfVxufVxuIl19