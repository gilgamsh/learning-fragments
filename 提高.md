### 基础算法

#### 位运算

##### 64位整数乘法

因为两个long long相乘会爆long long 所以选择 按照b的二进制位 一位位加

```
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL a,b,p,x;
int main()
{
    cin >> a >> b>> p;
    LL ans=0;
    x=a%p;//多少个a
    while(b){
        
        if(b&1){
            ans+=x;
            ans%=p;
            
            
            
        }
        x*=2;
        x%=p;
        b>>=1;
    }
    cout << ans;
}
```

#### 递推与递归

##### 费解的开关

按行 一行行确认 因为 一行的状态会影响上一行和下一行 枚举第一行所有可能的状态 上一行的状态可以确定下一行的状态 从上到下枚举每一行的可能状态即可。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 8;
int n;
int g[N][N];
int bp[N][N];
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

void do_(int x, int y) {//翻转每一个位置的数
    bp[x][y] ^= 1;
    for (int i = 0; i < 4; i++) {
        bp[x + dx[i]][y + dy[i]] ^= 1;
    }
}
void solve() {
    memset(g, 0, sizeof g);
    for (int i = 1; i <= 5; i++) {
        int t;
        cin >> t;
        for (int j = 1; j <= 5; j++) {
            if (t & 1) g[i][j] = 1;
            t /= 10;
        }
    }

    int ans = 1e9;

    for (int k = 0; k < 1 << 5;
         k++) {  //枚举第一行五展灯的按的方法
        memcpy(bp, g, sizeof g);
        int tmp = 0;
        int t = k, x1 = 1;
        while (t) {
            if (t & 1) tmp++, do_(1, x1);
            x1++, t >>= 1;
        }
        for (int i = 1; i <= 4; i++) {
            for (int j = 1; j <= 5; j++) {
                if (bp[i][j] == 0) tmp++, do_(i + 1, j);
            }
        }
        bool flag = true;
        for (int i = 1; i <= 5; i++) {
            if (bp[5][i] == 0) {
                flag = false;
                break;
            }
        }
        if (flag) ans = min(ans, tmp);
    }
    if (ans > 6) ans = -1;
    cout << ans << endl;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        solve();
    }
    return 0;
}
```

##### 约数之和

方法就是 对于每个质因数 从0次乘到p次 这里有一个logn的优化

```c++
#include<bits/stdc++.h>
#define x first
#define y second

using namespace std;
unordered_map<int,int> ump;
typedef long long LL;
const int MOD = 9901;
int a,b;

void get(int a){
    for(int i=2;i<=a/i;i++){
        if(a%i==0){
            int s=0;
            while(a%i==0)a/=i,s++;
            ump[i] +=s;
        }
    }
    if(a>1)ump[a]++;
}
int qmi(int a, int k, int p=9901)  // 求a^k mod p
{
    int res = 1 % p;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
LL sum(int a,int k){//a^0 + a^1 + a^2 + a^3 +... + a^k
    if(k==0)return 1;
    if(k%2==1){//a^0 + a^1 + a^2 + a^3 + a^k/2 +   a^k/2+1... + a^k
     return   sum(a,k/2)%MOD*(qmi(a,k/2+1)+1)%MOD; 
    }
    else{
      return sum(a,k-1)%MOD + qmi(a,k)%MOD;
    }
}

int main()
{
    cin >> a >> b;
    get(a);
    LL ans=1;
    for(auto t:ump){
        int a=t.x,k=t.y*b;//求a^0 + a^1 + a^2 + a^3 +... + a^k
        LL item = sum(a,k);
        ans = ans*item %MOD;
    }
    if(a)cout<<ans;
    else cout << 0;
}
```

#### 前缀和

##### 激光炸弹

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 5010;
int s[N][N];
int n,r;
int main()
{
    cin >> n >> r;
    for(int i=1;i<=n;i++){
        int x,y,w;
        scanf("%d%d%d", &x, &y, &w);
        s[x+1][y+1]+=w;
    }
    for(int i=1;i<N;i++){
        for(int j=1;j<N;j++){
            s[i][j]=s[i][j]+s[i-1][j]+s[i][j-1]-s[i-1][j-1];
        }
    }
    
    int maxn=0;
    for(int i=1;i<N;i++){
        for(int j=1;j<N;j++){
            int x2=i,y2=j;
            int x1=max(1,x2-r+1),y1=max(1,y2-r+1);
           maxn=max(maxn,s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]); 
        }
    }
    cout << maxn;
}
```

##### 增减序列

使用差分 最终目标是使得 除了b[1]之外全是0 贪心的情况 就是对于任意一对数 对于正数减一 对于负数加一 对于剩下的数 只能和b[1]或是b[n+1]一起操作

对于b[1]的操作从0 到 abs(pos-neg) 有  abs(pos-neg)+1种。

```
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 1e5+10;
int a[N];
int n;
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++ ){
        scanf("%d", &a[i]);
    }
    for (int i = n; i >= 1; i -- ){
        a[i]-=a[i-1];
    }
    
    LL pos=0,neg=0;
    for (int i = 2; i <= n; i ++ ){
        if(a[i]>0)pos+=a[i];
        else neg-=a[i];
    }
    cout << min(pos,neg)+abs(pos-neg)<<endl;
    cout << abs(pos-neg)+1;
}
```

#### 二分

##### 最佳牛围栏

二分答案 验证是否成立

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
typedef long long LL;
const int N = 1e5+10,INF=0x3f3f3f3f;
int a[N],b[N],n,f;
LL s[N];
bool check(int avg){
    LL minn=0;//
    memcpy(b,a,sizeof a);
    memset(s, 0, sizeof s);
    for (int i = 1; i <= n; i ++ ){
        b[i]=a[i]-avg;
    }
    for (int i = 1; i <= n; i ++ ){
        s[i]=s[i-1]+b[i];
    }//区间就是s[r]-s[l-1] 维护最小的s[l-1]即可
    for(int i=1;i<=n;i++){
        int pre=i-f;
        if(pre>=1)minn=min(minn,s[pre]);
        if(s[i]-minn>=0 && i>=f)return true;
    }
    return false;
}

int main()
{
    cin >>  n >> f;
    for(int i=1;i<=n;i++){
        scanf("%d", &a[i]);
        a[i]*=1000;
    }
    
    int l=1*1000,r=2000*1000;
    while(l<r){
        int mid = l+(r-l+1)/2;
        if(check(mid))l=mid;//查看平均是mid的区间是否存在 如果存在 答案就在[mid,r]的区间上
        else r=mid-1;
    }
    cout << r;
}
```

##### 特殊排序

任意有向完全图（又称竞赛图）都存在Hamilton路径。

关键在于找到一个位置j 对于i来说 a[j]<i<a[j+1] 在事实上 我们只需要找到最后一个j 满足a[j]<i的性质即可 假设a[j]<i 那么在大于j的右半区间一定有解

```c++
// Forward declaration of compare API.
// bool compare(int a, int b);
// return bool means whether a is less than b.

class Solution {
public:
    vector<int> specialSort(int N) {
        vector<int> a;
        for(int i=1;i<=N;i++){
            a.emplace_back(i);
        }
        stable_sort(a.begin(),a.end(),compare);//归并排序即可
        return a;
    }
};
```





#### 排序

##### 动态中位数

维护一个 对顶堆（一个大根堆 一个小根堆）大根堆的所有数 都小于小根堆的数 同时两个堆的size必须是大根堆比小根堆大一或者0

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220422134912821.png" alt="image-20220422134912821" style="zoom:80%;" />

```
#include<bits/stdc++.h>

using namespace std;
int t,m;
int main()
{
    cin >> t;
    while(t--){
        int n,m;
        cin >> n >> m;
        cout << n <<" "<< (m+1)/2 <<endl;
        
        priority_queue<int> down;
        priority_queue<int ,vector<int>,greater<int>> up;
        
        int cnt=0;
        for(int i=1;i<=m;i++){
            int x;
           scanf("%d", &x);
            if(down.empty() || x<=down.top())down.push(x);
            else up.push(x);
            
            if(down.size() > up.size()+1)up.push(down.top()),down.pop();
            if(up.size() > down.size() )down.push(up.top()),up.pop();
            if(i%2){
                cout << down.top()<<" ";
                cnt++;
                if(cnt==10)cout<<'\n',cnt=0;
            }
        }
        if(cnt)cout<<'\n';
    }
}
```

##### 



#### RMQ

##### 天才的记忆

f[i] [j] 表示 区间[i, i + (1<<j)-1]的最大值

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+10;
const int M = log(N)/log(2) + 50;
int n,m,a[N],f[N][M];
int main()
{
    cin >> n;
    for(int i=1;i<=n;i++){
        scanf("%d", &a[i]);
    }
    for(int i=1;i<=n;i++)f[i][0]=a[i];
    int t=log(n)/log(2)+5;
    for(int j=1;j<=t;j++){
        for(int i=1;i+(1<<j)-1<=n;i++){
            f[i][j]=max(f[i][j-1],f[i+(1<<j-1)][j-1]);
        }
    }
    cin >> m;
    for(int i=1;i<=m;i++){
        int l,r;
        scanf("%d%d", &l, &r);
        int len=r-l+1;
        int j=log(len)/log(2);
        cout << max(f[l][j],f[r-(1<<j)+1][j])<<'\n';
    }
}
```

### 数据结构

#### 并查集

##### 格子游戏

将二维的点化为一维

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 210*210 + 10,INF=0x3f3f3f3f;
int fa[N];
int n,m;
int get(int x,int y){
    return x*n+y;
}

int find(int x)  // 并查集
{
    if (fa[x] != x) fa[x] = find(fa[x]);
    return fa[x];
}

int main()
{
    cin >> n >> m;
    for(int i=0;i<=n*n+10;i++)fa[i]=i;
    int ans=INF;
    for(int i=1;i<=m;i++){
        int x,y;cin>>x>>y;
        char c;cin>>c;
        x--,y--;
        int a,b;
        a=get(x,y);
        if(c=='D') b=get(x+1,y);
        else b=get(x,y+1);
        
        int pa=find(a),pb=find(b);
        if(pa==pb){ans=i;break;}
        else {
            fa[pa]=pb;
        }
    }
    
    if(ans!=INF)cout<<ans;
    else puts("draw");
}
```

##### 搭配购买

使用并查集获得整合之后的物品价值和价格 最后简单背包问题

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 1e4+10;
int n,m,w;
int f[N],c[N],d[N];
int p[N];
bool st[N];

void init(){
    for(int i=0;i<=N;i++)p[i]=i;
}

int find(int x)  // 并查集
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}


int main()
{
    cin >> n >> m >>w;
    for(int i=1;i<=n;i++){
        scanf("%d%d", &c[i], &d[i]);
    }
    init();
    for(int i=1;i<=m;i++){
        int u,v;
        scanf("%d%d", &u, &v);
        int a=find(u),b=find(v);
        p[a]=b;
    }
    for(int i=1;i<=n;i++){
        int pi=find(i);
        st[pi]=true;
        if(pi==i)continue;
        c[pi]+=c[i],d[pi]+=d[i];
        
    }
    for(int i=1;i<=n;i++){
        if(!st[i])continue;
        for(int j=w;j>=c[i];j--){
            f[j]=max(f[j],f[j-c[i]]+d[i]);
        }
    }
    cout << f[w];
}
```

##### 程序自动分析

先考虑所有的相等约束 再验证不等约束 ***并查集只能维护可传递的关系***

相等关系是可传递的 不等关系是不可传递的

```c++
/*
 * @Date: 2022-05-02 10:08:31
 * @LastEditors: Juan Jiang
 * @LastEditTime: 2022-05-02 10:56:58
 * @FilePath: \提高\程序自动分析.cpp
 */
#include<bits/stdc++.h>
#define x first
#define y second
#define  eb emplace_back
using namespace std;
typedef pair<int, int> PII;
typedef unordered_map<int, int> UMII;
const int N=1e5+10,INF=0x3f3f3f3f;
int fa[2*N];
void init(){
    for(int i=0;i<2*N;i++)fa[i]=i;
}

int find(int x){
    if(fa[x]!=x){
        int u = find(fa[x]);//d[fa[x]]已经得到了
        fa[x]=u;
    }
    return fa[x];
}

void solve(){
    int n,idx=0;cin>>n;
    init();
    vector<PII> a,b;//a放相等情况 b放不相等情况
    UMII ump(N);
    for(int id=1;id<=n;id++){
        int i,j,e;
        cin>>i>>j>>e;
        if(e==1)a.eb(i,j);
        else b.eb(i,j);
        if(ump.find(i)==ump.end())ump[i]=idx++;
        if(ump.find(j)==ump.end())ump[j]=idx++;
    }
    for(auto it:a){
        int u=find(ump[it.x]),v=find(ump[it.y]);
        if(u!=v)fa[u]=v;
    }
    for(auto it:b){
        int u=find(ump[it.x]),v=find(ump[it.y]);
        //cerr<<u<<" "<<v<<endl;
        if(u==v){cout<<"NO"<<endl;return;}
    }
    cout<<"YES"<<endl;
}

int main(){
    int t;cin>>t;
    for(int i=1;i<=t;i++){
        solve();
    }
}
```

##### 奇偶游戏

每次query[l,r]的和是奇数还是偶数 都是在告诉我们sl-1 sr的奇偶性是相同的还是不相同的

```c++
/*
 * @Date: 2022-05-02 10:59:28
 * @LastEditors: Juan Jiang
 * @LastEditTime: 2022-05-02 21:55:40
 * @FilePath: \提高\奇偶游戏.cpp
 */
#include <bits/stdc++.h>
using namespace std;
const int N = 5e3 + 10;
int fa[2 * N], d[2 * N];

void init()
{
    for (int i = 0; i < 2 * N; i++)
        fa[i] = i, d[i] = 0;
}

int find(int x)
{
    if (fa[x] != x)
    {
        int u = find(fa[x]); // d[fa[x]]已经得到了
        d[x] += d[fa[x]];    //
        d[x] %= 2;
        fa[x] = u;
    }
    return fa[x];
}

int main()
{
    int n, m, idx = 0;
    cin >> n >> m;
    unordered_map<int, int> ump(2 * N);
    init();
    for (int i = 1; i <= m; i++)
    {
        int l, r, same;
        char c[5];
        scanf("%d%d%s", &l, &r, &c);
        if (c[0] == 'e')
            same = 1;
        else
            same = 0;

        if (ump.find(l - 1) == ump.end())
            ump[l-1] = ++idx;
        if (ump.find(r) == ump.end())
            ump[r] = ++idx;
        if (same)
        { //两段前缀和 奇偶性相同 l-1,r之间的关系是0
            int u = find(ump[l - 1]), v = find(ump[r]);

            if (u != v)
            {
                fa[u] = v;
                d[u] = d[ump[r]] - d[ump[l - 1]];
                d[u] %= 2;
                d[u] = (d[u]+2)%2;
            }
            else
            {
                if (d[ump[l - 1]] != d[ump[r]])
                {
                    cout << i - 1;
                    return 0;
                }
            }
        }

        else
        {
            int u = find(ump[l - 1]), v = find(ump[r]);

            if (u != v)
            {
                fa[u] = v;
                d[u] = d[ump[r]] + 1 - d[ump[l - 1]];
                d[u] %= 2;
                d[u] =(d[u]+2)%2;
            }
            else
            {
                if (d[ump[l - 1]] == d[ump[r]])
                {
                    cout << i - 1;
                    return 0;
                }
            }
        }
    }
    cout << m;
    return 0;
}
```

##### 银河英雄传说

除了距离之外，再维护一个每列的长度，以每列的开头作为根。

```c++
/*
 * @Date: 2022-05-02 22:07:33
 * @LastEditors: Juan Jiang
 * @LastEditTime: 2022-05-02 22:23:13
 * @FilePath: \提高\银河英雄传说.cpp
 */
#include<bits/stdc++.h>

using namespace std;
const int N=3e4+10;
int fa[N],d[N],len[N];//d[i]维护i节点到根节点的距离
void init(){
    for(int i=0;i<N;i++)fa[i]=i,d[i]=0,len[i]=1;
}

int find(int x){
    if(fa[x]!=x){
        int u=find(fa[x]);//d[fa[x]]已经得到了
        d[x]+=d[fa[x]];//
        fa[x]=u;
    }
    return fa[x];
}

int main(){
    int t;cin>>t;
    init();
    for(int id=1;id<=t;id++){
        char c;int i,j;
        cin>>c>>i>>j;
        if(c=='M'){
            int u=find(i),v=find(j);
            if(u!=v){
                fa[u]=v;
                d[u]=len[v];
                len[v]+=len[u]; 
            }
        }
        else{
            int u=find(i),v=find(j);
            if(u==v)printf("%d\n",max(0,abs(d[i]-d[j])-1));
            else printf("-1\n");
        }
    }

}
```

#### 树状数组

##### 楼兰图腾

求逆序对 单点修改 区间求值

```c++
#include<bits/stdc++.h>
#define lowbit(x) ((x)&(-x))
using namespace std;

typedef long long LL;
const int N=2e5+10;
int a[N];
int tree[N];//tree[i]记录每个数的个数
int le[N];//less[i]记录小于a[i]的数的个数 且数在a[i]的左边
int mo[N];//more[i]记录大于a[i]的数的个数 且数在a[i]的左边

void update(int i,int x){//i这个位置＋x 实际上就是1 tree[i]表示在[1,i]这个区间的个数
    for(int pos=i;pos<=N;pos+=lowbit(pos)){
        tree[pos]+=x;
    }
}

int query(int n){
    int ans=0;
    for(int pos=n;pos;pos-=lowbit(pos)){
        ans+=tree[pos];
    }
    return ans;
}

int query(int l,int r){
    return query(r)-query(l-1);
}


int main(){//对于每个a[i] 要求出a[1-i-1]中小于a[i]的数的个数   和a[i+1-n]中大于a[i]的数的个数
    int n;cin>>n;
    LL ans1=0,ans2=0;
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n;i++){
        update(a[i],1);//更新tree[i] [1-i]
        le[i]=query(a[i]-1);//le[i] 表示a[1-i-1]中小于a[i]的数的个数 * a[i+1-n]中小于a[i]的个数 
                            //  小于的数 a[i]-1个 左侧小于的数 le[i] 那么右侧小于的数 a[i]-1-le[i]个 
        mo[i]=i-1-le[i];//mo[i] 表示a[1-i-1]中大于a[i]的数的个数 * a[i+1-n]中大于a[i]的个数  
                            // 大于的数 n-a[i]个 左侧大于的数 mo[i]那么右侧大于的数 n-a[i]-mo[i]个
        ans1+=le[i]*(LL)(a[i]-1-le[i]);
        ans2+=mo[i]*(LL)(n-a[i]-mo[i]);
    }
    printf("%lld %lld\n",ans2,ans1);


}
```

##### 一个简单的整数问题

维护差分数组的前缀和 区间修改 单点查询

tip 永远不要用单个char读入 用char数组 当作s读入 

```c++
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-x))
using namespace std;
const int N = 1e5 + 10;
int a[N];
int tree[N]; //维护a[]的差分数组的树状数组

void update(int i, int x)
{
    for (int pos = i; pos <= N; pos += lowbit(pos))
    {
        tree[pos] += x;
    }
}

int query(int n)
{
    int ans = 0;
    for (int pos = n; pos; pos -= lowbit(pos))
    {
        ans += tree[pos];
    }
    return ans;
}

int query(int l, int r)
{
    return query(r) - query(l - 1);
}

int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
    }
    for (int i = 1; i <= n; i++)
    {
        int x = a[i] - a[i - 1];
        update(i, x);
    }
    for (int i = 1; i <= m; i++)
    {
        char op[12];
        scanf("%s", &op);
        if (op[0] == 'C')
        {
            int l, r, d;
            scanf("%d %d %d", &l, &r, &d);
            update(l, d);
            update(r + 1, -d);
        }
        if (op[0] == 'Q')
        {
            int x;
            scanf("%d", &x);
            int ans = query(x);
            printf("%d\n", ans);
        }
    }
}
```

##### 一个简单的整数问题2

区间修改 区间查询

维护b[i]的树状数组 和 维护i*b[i]的树状数组

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220503213657104.png" alt="image-20220503213657104" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-x))
using namespace std;
typedef long long LL;
const int N = 1e5 + 10;
int a[N];
LL tree[2][N]; //维护差分数组b[]的树状数组
 //维护i*b[]的树状数组

void update(int i, LL x,LL tree[])
{
    for (int pos = i; pos <= N; pos += lowbit(pos))
    {
        tree[pos] += x;
    }
}

LL query(int n,LL tree[])
{
    LL ans = 0;
    for (int pos = n; pos; pos -= lowbit(pos))
    {
        ans += tree[pos];
    }
    return ans;
}

LL query(int l, int r,LL tree[])
{
    return query(r,tree) - query(l - 1,tree);
}


LL query(int n){
    LL ans=0;
    ans+=(n+1)*(LL)query(n,tree[0]);
    ans-=query(n,tree[1]);
    return ans;
}

int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
    }
    for (int i = 1; i <= n; i++)
    {
        int x = a[i] - a[i - 1];
        update(i, x,tree[0]);
        update(i, i*(LL)x,tree[1]);
    }
    for (int i = 1; i <= m; i++)
    {
        char op[12];
        scanf("%s", &op);
        if (op[0] == 'C')
        {
            int l, r, d;
            scanf("%d %d %d", &l, &r, &d);

            update(l, d,tree[0]);
            update(r + 1, -d,tree[0]);
            update(l, d*(LL)l,tree[1]);
            update(r + 1, -d*(LL)(r+1),tree[1]);

        }
        if (op[0] == 'Q')
        {
            int l,r;
            scanf("%d %d", &l, &r);
            LL ans = query(r)-query(l-1);
            printf("%lld\n", ans);
        }
    }
}
```

##### 迷一样的牛

从剩余的数中，找到第K小的数

```c++
#include <bits/stdc++.h>
#define lowbit(x) ((x) & (-x))
using namespace std;
const int N = 1e5 + 10;
int tree[N];
int a[N];
int b[N];

void update(int i, int x)
{
    for (; i <= N; i += lowbit(i))
    {
        tree[i] += x;
    }
}
int query(int n)
{
    int ans = 0;
    for (; n > 0; n -= lowbit(n))
    {
        ans += tree[n];
    }
    return ans;
}

bool judge(int pos,int x){
    int sum=query(pos);
    if(sum>=x)return true;
    else return false;
}

int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        update(i, 1);
    }
    for (int i = 2; i <= n; i++)
        scanf("%d", &a[i]);

    for (int i = n; i >= 1; i--)
    {
        int k = a[i] + 1;     //第k个1的下标就是奶牛的高度
        int l = 1, r= n; // sum记录[1-idx]的1的个数
        //if(i==3)cerr<<k<<endl;
        while(l<r){
            int mid=l+r >>1;
            if(judge(mid,k))r=mid;
            else l=mid+1;
        }

        update(l, -1);
        b[i] = r;
    }
    for (int i = 1; i <= n; i++)
    {
        printf("%d\n", b[i]);
    }
}
```

#### 线段树

##### 最大数

树状数组不能维护最大数这样的信息，因为两个前缀区间的最大值并不能求出区间的最大值。只能用线段树。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 2e5 + 10;

struct Node
{
    int l,r,v;
};
Node tr[4*N];
void pushup(int u){
    tr[u].v = max(tr[2*u].v , tr[2*u+1].v);//利用子节点信息计算父节点信息
}
void build(int u,int l,int r){
    tr[u] = {l,r};//首先给u这个节点分配区间
    if(l==r)return;//如果是叶节点 那么结束了
    int mid = (l+r)>>1;
    build(2*u,l,mid);//左节点
    build(2*u+1,mid+1,r);//右节点
    //pushup(u); 一开始还没有值 都是0
}

int query(int u,int l,int r){
    if(tr[u].l >= l && tr[u].r <= r) return tr[u].v;//l<=tr[u].l <= tr[u].r <=r
    int mid = (tr[u].l+tr[u].r)>>1;
    if(r <= mid) return query(2*u,l,r);//tr[u].l<= r<=mid 左子树
    if(l > mid) return query(2*u+1,l,r);//mid < l < tr[u].r 右子树
    return max(query(2*u,l,r),query(2*u+1,l,r));
}

void modify(int u,int x,int v){//把x位置上的数改成v
    if(tr[u].l == x && tr[u].r == x) {tr[u].v = v; return;}
    int mid = (tr[u].l+tr[u].r)>>1;
    if(x <= mid) modify(2*u,x,v);
    else modify(2*u+1,x,v);
    pushup(u);
}

int main(){
    int n=0,last=0;
    int m,p;cin>>m>>p;
    build(1,1,m);
    
    for(int i=1;i<=m;i++){
        char op[2];int x;
        scanf("%s%d",op,&x);
        if(op[0]=='Q'){
            last=query(1,n-x+1,n);
            printf("%d\n",last);
        }
        else{
            modify(1,n+1,((LL)x+last)%p);
            n++;
        }
    }
    return 0;
}
```



### DP

#### 数字三角形模型

##### 摘花生

网格 左上到右下 不走回头路 求最大值

1. dp 阶段、决策 最优子结构 无后效性

2. 从集合角度来考虑dp问题 
   1. 状态表示 f[i,j] 
      1. 集合 所有从(1,1)走到(i,j)的路线（以左上为原点  x向下 y向右 和打印顺序一样）
      2. 属性 Max/Min/数量
      
   2. 状态计算 常用的**划分依据**  “最后一步”  **划分原则** 不漏 不重复
   
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 110;
int a[N][N];
LL f[N][N];
void solve(){
    int r,c; cin >> r>>c;
    memset(a,0,sizeof a);
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            cin >> a[i][j];
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j]; //
    cout << f[r][c]<<endl;
}
int main()
{
    int t;cin >> t;
    for (int i = 1; i <= t; i ++ )solve();
} 
```

##### 最低通行费

网格  左上到右下 不走回头路 求最小值

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int a[N][N];
int f[N][N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            cin >> a[i][j];
    for (int i = 1; i <= n; i ++ )f[i][1]=f[i-1][1]+a[i][1];
    for (int i = 1; i <= n; i ++ )f[1][i]=f[1][i-1]+a[1][i];
    for (int i=2;i<=n;i++)
        for (int j = 2; j <= n; j ++ )
            f[i][j]=min(f[i-1][j],f[i][j-1])+a[i][j];
    cout << f[n][n];
}
```

##### 方格取数      

方格 左上到右下 不走回头路  走两次 两次相关 同时枚举 最后一步的情况是四种 当两条路径重合的时候 

**格子值只会被计算一次** 可以重合 但是值只算一次 所以计算f数组的值的时候 需要考虑两条路径是不是有重合 **而只有两个路线的步数一致时 才有可能重合。所以用K表示步数**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 20;
int a[N][N];
int f[2*20][N][N];
int main()
{
    int n;cin>>n;
    int r=1,c,num;
    while(r!=0){
        cin >> r>>c>>num;
        if(r==0)break;
        a[r][c]=num;
    }
    f[2][1][1]=a[1][1];
    for(int k=3;k<=2*n;k++){
        for(int i=1;i<k&&i<=n;i++){
            for(int j=1;j<k&&j<=n;j++){
                int t =a[i][k-i];
                if(i!=j) t+=a[j][k-j];
                int & tmp=f[k][i][j];
                tmp=max(tmp,f[k-1][i-1][j]+t);
                tmp=max(tmp,f[k-1][i-1][j-1]+t);
                tmp=max(tmp,f[k-1][i][j-1]+t);
                tmp=max(tmp,f[k-1][i][j]+t);
            }
        }
    }
    cout << f[2*n][n][n];
}
```

##### 传纸条

网格 左上到右下 两条 不能重复 求路径上的最大值

状态表示是有意义的 **可以推出答案** **每个状态可被计算**  和方格取数本质上一样 方格取数中 两条路径也不会有交点

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 55;
int a[N][N];
int f[2*N][N][N];
int main()
{
    int m,n;cin>>m>>n;
    for (int i = 1; i <= m; i ++ ){
        for (int j = 1; j <= n; j ++ ){
            cin >> a[i][j];
        }
    }
    f[2][1][1]=a[1][1];
    for(int k=3;k<=m+n;k++){
        for(int i=1;i<k&&i<=m;i++){
            for(int j=1;j<k&&j<=m;j++){
                if(k!=m+n && i==j)continue;
                int t =a[i][k-i];
                t+=a[j][k-j];
                int &tmp=f[k][i][j];
                tmp=max(tmp,f[k-1][i-1][j]+t);
                tmp=max(tmp,f[k-1][i-1][j-1]+t);
                tmp=max(tmp,f[k-1][i][j-1]+t);
                tmp=max(tmp,f[k-1][i][j]+t);
            }
        }
    }
    //cout<<f[5][2][3]<<endl;
    
    cout << f[m+n-1][m][m-1];
}
```

#### 最长上升子序列模型

##### 怪盗基德的滑翔翼

注意可以从两端算起 $$O(n^2)$$做法

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 110;
int a[N];
int f[N];
void solve(){
    memset(a, 0, sizeof a);
    memset(f, 0, sizeof f);
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }
    for (int i = 1; i <= n; i ++ )f[i]=1;
    for (int i = 1; i <= n; i ++ ){
        for (int j = 1; j < i; j ++ ){
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    memset(f, 0, sizeof f);
    for (int i = n; i >= 1; i -- )f[i]=1;
    for (int i = n; i >= 1; i -- ){
        for (int j = n; j > i; j -- ){
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout<<res<<endl;
}

int main()
{
    int k;cin>>k;
    for (int i = 1; i <= k; i ++ )solve();
}
```

##### 登山

先求最长上升 再求最长下降 然后两个状态重叠

1. 编号递增 子序列
2. 一旦开始下降就不难上升 先上升再下降

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N],f[N],g[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin >> a[i],f[i]=g[i]=1;
    for (int i = 1; i <= n; i ++ ){
        for (int j = 1; j < i; j ++ ){
            if(a[j]<a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for (int i = n; i >= 1; i -- ){
        for (int j = n; j > i; j -- ){
            if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]+g[i]-1);
    cout << res <<endl;
}
```

##### 合唱队形

序列 求最长上升和最长下降 然后取一个总和的状态 上面的对偶问题

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int a[N];
int f[N],g[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin >>a[i];
    for(int i=1;i<=n;i++){
        f[i]=1;
        for (int j = 1; j < i; j ++ ){
            if(a[j]<a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for(int i=n;i>=1;i--){
        g[i]=1;
        for (int j = n; j > i; j -- ){
            if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]+g[i]-1);
    cout << n-res;
}
```

##### 友好城市

要保证没有交集，那么就需要保证上下两个序列均为上升的 排序了下面的序列，那么就已经能保证下方的序列为上升的，在这个的前提下就可以将这个题目转换为求最长上升子序列

```c++
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
const int N = 5010;
typedef pair<int,int> PII;
PII a[N];
int b[N],f[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ ){
        int x,y;cin>>x>>y;
        a[i]={x,y};
    }
    sort(a+1,a+n+1);
    for (int i = 1; i <= n; i ++ )b[i]=a[i].y;
    for (int i = 1; i <= n; i ++ ){
        f[i]=1;
        for (int j = 1; j < i; j ++ )
            if(b[j]<=b[i])f[i]=max(f[i],f[j]+1);
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout << res;
}
```

##### 最大上升子序列和

维护的属性变成最大上升子序列的和的最大值

```c++
#include <bits/stdc++.h>
using namespace std;
const int N=1010;
int a[N],f[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin>>a[i];
    for (int i = 1; i <= n; i ++ ){
        f[i]=a[i];
        for (int j = 1; j < i; j ++ )
            if(a[j]<a[i])f[i]=max(f[i],f[j]+a[i]);
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout << res;
}
```

##### 拦截导弹

Dilworth定理：偏序集的最少反链划分数等于最长链的长度，说简单点其实就是第二问相当于求最长上升子序列

具体动机 如下

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323204343366.png" alt="image-20220323204343366" style="zoom: 80%;" />

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323204412485.png" alt="image-20220323204412485" style="zoom:80%;" />

调整的方法在于 将第一个不同的数交换 可以将贪心法找到的解调整为最优解 并且每次调整没有增加解的个数

贪心的过程类似于

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N],idx,f[N],g[N];
int main()
{
    int tmp;
    while(scanf("%d",&tmp)==1){
        a[++idx]=tmp;
    }
    for (int i = 1; i <= idx; i ++ ){
        f[i]=1;
        for (int j = 1; j < i; j ++ )
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
    }
    for (int i = 1; i <= idx; i ++ ){
        g[i]=1;
        for (int j = 1; j < i; j ++ )
        if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
    }
    int res1=0,res2=0;
    for (int i = 1; i <= idx; i ++ )res1=max(res1,f[i]);
    for (int i = 1; i <= idx; i ++ )res2=max(res2,g[i]);
    cout << res1<<endl;
    cout << res2;
}
```

##### 导弹防御体系

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323214812369.png" alt="image-20220323214812369" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 55;
int n,a[N],up[N],down[N];
bool dfs(int depth,int id,int u,int d)//u是上升子序列的数目 d是下降子序列的数目  i是当前需要处理的数字的序号
{
    if(u+d>depth)return false;
    if(n+1==id)return true;//当要处理的下标越界时 处理完毕了
    
    //枚举放入最长上升子序列的情况  up数组单减 
    bool flag=false;
    for(int i=1;i<=u;i++){
        if(up[i]<a[id]){
            int t=up[i];//u[i]旧值 用于回溯
            up[i]=a[id];
            if(dfs(depth,id+1,u,d))return true;
            flag=true;
            up[i]=t;
            break;
        }
    }
    if(!flag){
        up[u+1]=a[id];
        if(dfs(depth,id+1,u+1,d))return true;
    }
    
    flag=false;
    for(int i=1;i<=d;i++){//down 数组单增
        if(down[i]>a[id]){
            int t=down[i];
            down[i]=a[id];
            if(dfs(depth,id+1,u,d))return true;
            flag=true;
            down[i]=t;
            break;
        }
    }
    if(!flag){
        down[d+1]=a[id];
        if(dfs(depth,id+1,u,d+1))return true;
    }
    return false;
}

void solve(){
    int depth=0;
    while(!dfs(depth,1,0,0))depth++;
    cout << depth<<endl;
}

int main()
{
    cin>>n;
    while(n!=0){
        memset(a,0,sizeof a);
        for (int i = 1; i <= n; i ++ )cin>>a[i];
        solve();
        cin >> n;
    }
}
```

##### 最长上升公共子序列

不能先求公共子序列 再求上升自序列 

反例 

5

5 3 2 1 4    最长的公共自序列是 5 4 或者 3 4等等

3 5 4 2 1 

注意此例

10
1 5 3 6 3 2 7 3 6 2 
9 6 2 3 1 5 3 3 6 1  考虑f[1] [5]

![image-20220324205252518](C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220324205252518.png)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3010;
int n, a[N], b[N], f[N][N];
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> a[i];
  for (int i = 1; i <= n; i++) cin >> b[i];
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      int &x = f[i][j];
      x = f[i - 1][j];
      if (a[i] == b[j]){
        x=1;
        for (int k = 1; k < j; k++) {
          if (b[k] < b[j]) x = max(x, f[i - 1][k] + 1);
        }
        }
    }
  }
  int res = 0;
  for(int i=1;i<=n;i++){
      for (int j = 1; j <= n; j ++ ){
          cout << f[i][j]<<" ";
      }
      puts("");
  }
  cout << res;
}
```

然后我们发现每次循环求得的maxv是满足a[i] > b[k]的f[i - 1] [k] + 1的前缀最大值。
因此可以直接将maxv提到第一层循环外面，减少重复计算，此时只剩下两重循环。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3010;
int n, a[N], b[N], f[N][N];
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> a[i];
  for (int i = 1; i <= n; i++) cin >> b[i];
  
  for (int i = 1; i <= n; i++) {
    int maxv=0;//记录 f[i-1][j]的前j个数的最大值
    for (int j = 1; j <= n; j++) {//此时maxv的值是f[i-1][j-1]的前缀最大值
      int &x = f[i][j];
      x = f[i - 1][j];
      if (a[i] == b[j]){
        x=max(x,maxv+1);    //第j个在
      }
      if(a[i]>b[j])maxv=max(maxv,f[i-1][j]);//更新f[i-1][j]的前缀最大值
    }
  }
  int res = 0;
  for(int i=1;i<=n;i++){
      for (int j = 1; j <= n; j ++ ){
          res=max(res,f[i][j]);
      }
  }
  cout << res;
}
```

#### 背包

##### 采药

如果 不能放下第j个 也要记得更新

```c++
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 110,M=1010;
PII a[N];
int t,m;
int f[N][M];
int main()
{
    cin >> t>>m;
    for (int i = 1; i <= m; i ++ )cin>>a[i].x>>a[i].y;
    for (int i = 1; i <= m; i ++ ){
        int tt=a[i].x,nn=a[i].y;
        for(int j=1;j<=t;j++){
            f[i][j]=f[i-1][j];
            if(j>=tt)f[i][j]=max(f[i-1][j],f[i-1][j-tt]+nn);
        }
    }
    cout << f[m][t];
}
```

##### 装箱问题

题目里面 价值 和 体积是值一样

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 40,V=20010;
int v,n;
int a[N],f[N][V];
int main()
{
    cin >> v>>n;
    for (int i = 1; i <= n; i ++ ) cin>>a[i];
    for (int i = 1; i <= n; i ++ ) f[i][0]=1,f[i][a[i]]=1;
    
    for (int i = 1; i <= n; i ++ ){
        for (int j = 0; j <= v; j ++ ){
            if(f[i-1][j])f[i][j]=1;
            if(f[i-1][j]&&j+a[i]<=v)f[i][j+a[i]]=1;
        }
    }
    int res=0;
    for (int j = 0; j <= v; j ++ )if(f[n][j])res=j;
    cout << v-res;
}
```

##### 宠物小精灵之收服

在背包问题中，体积w与价值v是可以互逆的！
可以将f[i]表示为体积为i能装的最大价值，也可以将f[i]表示为价值为i所需的最小体积。
两者等价，我们只需要选择范围较小的那维作为体积就可以了！ 这直接影响到时空复杂度。

朴素的二维的dp

```c++
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 1010, M = 510, K = 110;
PII a[K];
int n, m, k, f[2][M][N];
int main() {
  cin >> n >> m >> k;
  for (int i = 1; i <= k; i++) {
    cin >> a[i].x >> a[i].y;
  }
  for (int i = 1; i <= k; i++) {      //枚举k个小精灵
    for (int j = 0; j < m; j++) {     // j是体力值
      for (int w = 0; w <= n; w++) {  // w是精灵球的数量
        int ww = a[i].x, jj = a[i].y;
        int &x = f[i % 2][j][w];
        x = f[(i - 1) % 2][j][w];
        if (w >= ww && j >= jj) x = max(x, f[(i - 1) % 2][j - jj][w - ww] + 1);
      }
    }
  }
  int c = 0, r = m;
  for (int i = 0; i < m; i++) {
    for (int j = 0; j <= n; j++) {
      if (f[k % 2][i][j] > c) {
        c = f[k % 2][i][j];
        r = m - i;
      }
      if (f[k % 2][i][j] == c) {
        r = max(r, m - i);
      }
    }
  }
  cout << c << " " << r;
  return 0;
}
```

优化做法  太痛苦了 忘记初始化了 如果

```c++
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 1010, M = 510, K = 110, INF = 0x3f3f3f3f;
PII a[K];
int n, m, k, f[2][M][K];
int main() {
  memset(f, 0x3f, sizeof f);
  cin >> n >> m >> k;
  for (int i = 1; i <= k; i++) {
    cin >> a[i].x >> a[i].y;
  }
  memset(f, 0x3f, sizeof f);
  f[0][0][0] = 0;                     //不抓小精灵肯定不用精灵球
  f[1][0][0] = 0;                     //不抓小精灵不用精灵球
  for (int i = 1; i <= k; i++) {      //枚举考虑第i个小精灵
    for (int j = 0; j < m; j++) {     //花费了m体力
      for (int w = 0; w <= i; w++) {  //抓了i个小精灵
        int &t = f[(i) % 2][j][w];
        t = f[(i - 1) % 2][j][w];  //最少多少精灵球
        int nn = a[i].x, tt = a[i].y;
        if (j >= tt && w >= 1 && f[(i - 1) % 2][j - tt][w - 1] + nn <= n)
          t = min(t, f[(i - 1) % 2][j - tt][w - 1] + nn);
      }
    }
  }
  int c = 0, r = m;
  for (int i = 0; i < m; i++) {
    for (int j = 1; j <= k; j++) {
      if (f[(k) % 2][i][j] <= n) {
        if (c < j)
          r = m - i, c = j;
        else if (c == j)
          r = max(r, m - i);
      }
    }
  }

  cout << c << " " << r;
  return 0;
}
```

##### 数字组合

M看成是背包容量 每个数是一个物品 Ai是体积 总体积恰好是M的方案数

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220325153819418.png" alt="image-20220325153819418" style="zoom:80%;" />

```c++
//已知 有n个数 目标是和为n  求最大方案数
#include <bits/stdc++.h>
using namespace std;
const int N = 110, M = 10010;
int n, m, a[N], f[N][M];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) cin >> a[i];

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      int &x = f[i][j];
      x = f[i - 1][j];  //不用第i个数
      if (j > a[i])
        x += f[i - 1][j - a[i]];  //用第i个数
      else if(j==a[i])
        x += 1;
    }
  }
  cout << f[n][m];

  return 0;
}
```

##### 买书

完全背包问题 变成了方案数  需要把n元全部花完

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220325155312279.png" alt="image-20220325155312279" style="zoom:80%;" />

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[5]={0,10,20,50,100},n;
int f[2][N];
int main()
{
    cin >> n;
    f[0][0]=f[1][0]=1;
    for (int i = 1; i <= 4; i ++ ){
        for (int j = 0; j <= n; j ++ ){
            int &x=f[i%2][j];
            x=f[(i-1)%2][j];//不买第i本书
            if(j>a[i])x+=f[(i)%2][j-a[i]];
            else if(j==a[i])x+=1;
        }
    }
    cout<<f[4%2][n];
}
```

##### 货币系统

卡int了 n个物品 容量为m的背包 完全背包

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 20,M=3010;
LL n,m,a[N],f[2][M];
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ){//
        cin >> a[i];
    }
    f[0][0]=f[1][0]=1;
    for (int i = 1; i <= n; i ++ ){
        for (int j = 1; j <= m; j ++ ){
            LL &x=f[i%2][j];
            x=f[(i-1)%2][j];//不用第i个货币 组成j的方案
            if(j>=a[i])x+=f[(i)%2][j-a[i]];// 
        }
    }
    cout << f[n%2][m];
}
```

##### 货币系统（中等）

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220325232353785.png" alt="image-20220325232353785" style="zoom:80%;" />

将a1 a2 an从小到大排序 因为这里的系数非负 所以只能小数来表示大数

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110, M = 25010;
int a[N], f[2][M];
void solve() {
  memset(a, 0, sizeof a);
  memset(f, 0, sizeof f);
  int n;
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> a[i];
  sort(a + 1, a + n + 1);
  int m = a[n], res = 0;
  f[0][0] = f[1][0] = 1;
  for (int i = 1; i <= n; i++) {
    if (!f[(i - 1) % 2][a[i]]) res++;//如果前i个数不能表示 a[i]
    for (int j = 1; j <= m; j++) {
      int &x = f[i % 2][j];
      x = f[(i - 1) % 2][j];
      if (j >= a[i]) x |= f[i % 2][j - a[i]];
    }
  }
  cout << res << endl;
}
int main() {
  int t;
  cin >> t;
  for (int i = 1; i <= t; i++) {
    solve();
  }
  return 0;
}
```

##### 多重背包问题（单调队列优化）

传统推导

```c++
dp[i][j] 表示将前 i 种物品放入容量为 j 的背包中所得到的最大价值
dp[i][j] = max(不放入物品 i，放入1个物品 i，放入2个物品 i, ... , 放入k个物品 i)
这里 k 要满足：k <= s, j - k*v >= 0

不放物品  i = dp[i-1][j]
放k个物品 i = dp[i-1][j - k*v] + k*w

dp[i][j] = max(dp[i-1][j], dp[i-1][j-v] + w, dp[i-1][j-2*v] + 2*w,..., dp[i-1][j-k*v] + k*w)
```

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220326103237845.png" alt="image-20220326103237845" style="zoom:80%;" />

r是j 模v的余数

```c++
#pragma GCC optimize(3)
#pragma GCC optimize("inline")
#include <bits/stdc++.h>
using namespace std;
const int N = 20010;
int n, m;
int f[2][N];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    int v, w, s;
    cin >> v >> w >> s;          //每件体积是v 价值是w 数量是s
    for (int r = 0; r < v; r++)  // 体积除以v的余数
    {
      deque<int> Q;
      for (int k = r; k <= m; k += v)  //模v的 r的同余类
      {
        if (!Q.empty() && (k - Q.front()) / v > s) Q.pop_front(); // 是否超过了s个
        while (!Q.empty() &&
               f[(i - 1) % 2][Q.back()] - (Q.back() - r) / v * w <=
                   f[(i - 1) % 2][k] - (k - r) / v * w)
          Q.pop_back();
        Q.push_back(k);
        f[i % 2][k] = f[(i - 1) % 2][Q.front()] + (k - Q.front()) / v * w;
      }
    }
  }

  cout << f[n % 2][m] << endl;

  return 0;
}
```

##### 庆功会

多重背包

```c++
#include<bits/stdc++.h>
using namespace std;
const int M = 6010;
int n,m,f[2][M];
int main()
{
    cin >> n >>m;
    for (int i = 1; i <= n; i ++ ){
        int v,w,s;
        cin >> v>> w>> s;
        for (int r = 0; r < v; r ++ ){
            deque<int> Q;
            for (int j = r; j <= m; j +=v ){
                while(!Q.empty() && (j-Q.front())/v >s )Q.pop_front();
                while(!Q.empty() && f[(i-1)%2][Q.back()]-(Q.back()-r)/v*w <= 
                                    f[(i-1)%2][j]-(j-r)/v*w)Q.pop_back();
                Q.push_back(j);
                f[i%2][j]=f[(i-1)%2][Q.front()] + (j-Q.front())/v*w;
            }
        }
    }
    cout << f[n%2][m];
}
```

##### 混合背包问题

有三类物品 第一类只能用1次 第二类可以无限次，第三类可以si次

```c++
#include <bits/stdc++.h>
using namespace std;
const int V = 1010, INF = 0x3f3f3f3f;
int n, vv, f[2][V];
int main() {
  cin >> n >> vv;
  for (int i = 1; i <= n; i++) {
    int v, w, s;
    cin >> v >> w >> s;
    if (s == -1 || s == 0) {
      for (int j = 0; j <= vv; j++) {
        int &x = f[i % 2][j];
        x = f[(i - 1) % 2][j];
        if (s == -1) {
          if (j >= v) x = max(x, f[(i - 1) % 2][j - v] + w);
        }
        if (s == 0) {
          if (j >= v) x = max(x, f[(i) % 2][j - v] + w);
        }
      }
    } else {
      for (int r = 0; r < v; r++) {
        deque<int> Q;
        for (int j = r; j <= vv; j += v) {
          int &x = f[i % 2][j];
          x = f[(i - 1) % 2][j];
          while (!Q.empty() && (j - Q.front()) / v > s) Q.pop_front();
          while (!Q.empty() &&
                 f[(i - 1) % 2][Q.back()] - (Q.back() - r) / v * w <=
                     f[(i - 1) % 2][j] - (j - r) / v * w)
            Q.pop_back();
          Q.push_back(j);
          x = max(x, f[(i - 1) % 2][Q.front()] + (j - Q.front()) / v * w);
        }
      }
    }
  }

  cout << f[n % 2][vv];

  return 0;
}
```

##### 二维费用的背包问题

限制不只有体积 还有重量 也就是限制变成了二维的 

```c++
#include <bits/stdc++.h>
using namespace std;
const int V = 110, M = 110;
int n, v, m, f[2][V][M];
int main() {
  cin >> n >> v >> m;
  for (int i = 1; i <= n; ++i) {
    int vi, mi, wi;
    cin >> vi >> mi >> wi;
    for (int j = 0; j <= v; j++) {
      for (int k = 0; k <= m; k++) {
        int &x = f[i & 1][j][k];
        x = f[(i - 1) % 2][j][k];
        if (j >= vi && k >= mi) x = max(x, f[(i - 1) % 2][j - vi][k - mi] + wi);
      }
    }
  }
  cout << f[n % 2][v][m];
  return 0;
}
```

##### 潜水员

至多，恰好，至少 这三种状态转移方程都是一样的，
不同的是状态的定义域不同（前两者在负数上没有定义，后者有）和初始边界的不同了。

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220326212543063.png" alt="image-20220326212543063" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
using namespace std;
const int M = 26, N = 89;
int m, n, k, f[2][M][N];
int main() {
  memset(f, 0x3f, sizeof f);
  cin >> m >> n >> k;
  f[0][0][0] = f[1][0][0] = 0;
  for (int i = 1; i <= k; i++) {
    int a, b, c;
    cin >> a >> b >> c;
    for (int j = 0; j <= m; j++) {    //氧气
      for (int w = 0; w <= n; w++) {  //氮气
        int &x = f[(i) % 2][j][w];
        x = f[(i - 1) % 2][j][w];
        x = min(x, f[(i - 1) % 2][max(0, j - a)][max(0, w - b)] + c);
      }
    }
  }
  cout << f[k % 2][m][n] << endl;
  return 0;
}
```



##### 机器分配

转化为分组背包问题 循环从外到内 是 分组数 体积大小 数目

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 15, M = 25;
int n, m, f[N][M], ww[N][M];
int way[N];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      int w;
      cin >> w;
      ww[i][j] = w;
      for (int k = 0; k <= m; k++) {
        int &x = f[i][k];
        x = max(x, f[(i - 1)][k]);
        if (k >= j) x = max(x, f[(i - 1)][k - j] + w);
      }
    }
  }

  cout << f[n][m] << endl;
  int left = m;  //剩余的机器数
  for (int i = n; i >= 1; i--) {
    for (int j = 0; j <= left; j++) {
      if (f[i][left] == f[i - 1][left - j] + ww[i][j]) {
        way[i] = j;
        left -= j;
        break;
      }
    }
  }
  for (int i = 1; i <= n; i++) cout << i << " " << way[i] << endl;
  return 0;
}
```

##### 开心的金明

01背包

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3e4 + 5;
int n, m, f[2][N];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= m; i++) {
    int v, p;
    cin >> v >> p;
    int w = v * p;
    for (int j = 0; j <= n; j++) {
      int &x = f[i % 2][j];
      x = f[(i - 1) % 2][j];
      if (j >= v) x = max(x, f[(i - 1) % 2][j - v] + w);
    }
  }
  cout << f[m % 2][n];
  return 0;
}
```

##### 有依赖的背包问题

转化为分组背包问题 一组是一颗子树 每一件物品是改子树的每一个体积的值

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
struct Edge {
  int to;
  Edge(int _to) { to = _to; }
};
vector<Edge> edges[N];
struct Thing {
  int v, w;
};
Thing things[N];
int n, v, f[N][N];

void dfs(int u) {
  int vv = things[u].v, ww = things[u].w;
  for (auto t : edges[u]) {//分组背包先 循环组数 再循环体积 再循环每组中的物品
    dfs(t.to);
    for (int j = v; j >= 0; j--) {//体积要从大到小 因为f[t.to][k]的值只能选一次
      for (int k = 0; k <= j; k++) {
        if (j >= k) f[u][j] = max(f[u][j], f[u][j - k] + f[t.to][k]);
      }
    }
  }//先考虑只选择子树
  for (int i = v; i >= vv; i--) f[u][i] = f[u][i - vv] + ww;//一定要选根
  for (int i = 0; i < vv; i++) f[u][i] = 0;
}

int main() {
  cin >> n >> v;
  int root;
  for (int i = 1; i <= n; i++) {
    int p;
    cin >> things[i].v >> things[i].w >> p;
    if (p == -1)
      root = i;
    else
      edges[p].emplace_back(i);
  }
  dfs(root);
  cout << f[root][v];
  return 0;
}
```

##### 背包问题求方案数



```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, mod = 1000000007;

int n, m;
int f[N], g[N];
int v[N], w[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

    for (int i = 0; i <= m; i ++ ) g[i] = 1;

    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= v[i]; j -- )
        {
            int left = f[j], right = f[j - v[i]] + w[i];
            f[j] = max(left, right);

            if (left > right) g[j] = g[j];
            else if (left < right) g[j] = g[j - v[i]];
            else g[j] = g[j] + g[j - v[i]];
            g[j] %= mod;
        }

    cout << g[m] << endl;
    return 0;
}
```

##### 背包问题求具体方案

本质上讲 dp可以变成最短路问题 从终点 反推到起点  由于倒退只能从后往前的字典序最小 所以把物品的顺序反一下 求dp

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int n, m, f[N][N], way[N], v[N], w[N];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) cin >> v[n - i + 1] >> w[n - i + 1];
  for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= m; j++) {
      int &x = f[i][j];
      x = f[(i - 1)][j];
      if (j >= v[i]) x = max(x, f[(i - 1)][j - v[i]] + w[i]);
    }
  }
  int j = m, idx = 0;
  for (int i = n; i >= 1; i--) {
    if (j >= v[i] && f[i][j] == f[i - 1][j - v[i]] + w[i]) {
      way[++idx] = i;
      j -= v[i];
      continue;
    }
    if (f[i][j] == f[i - 1][j]) {
      continue;
    }
  }
  for (int i = 1; i <= idx; i++) {
    cout << n - way[i] + 1 << " ";
  }

  return 0;
}
```

##### 能量石

贪心+DP 首先如果直接DP 需要枚举 吃的石头的方案和吃的顺序。 通过贪心 可以将吃的顺序固定。证明类似于国王游戏和叠罗汉

之后使用DP 类似于0x背包

贪心的证明

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220328173304603.png" alt="image-20220328173304603" style="zoom:80%;" />

01背包过程

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220328173221751.png" alt="image-20220328173221751" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110, T = 10010, INF = 0x3f3f3f3f;
struct Stone {
  int s, e, l;
  bool operator<(const Stone& x) const { return s * x.l < l * x.s; }
};
Stone a[N];
int f[2][T];
void solve(int k) {
  memset(a, 0, sizeof a);
  memset(f, 0, sizeof f);
  int n, t = 0;
  cin >> n;
  for (int i = 1; i <= n; i++) {
    int s, e, l;
    cin >> s >> e >> l;
    a[i] = {s, e, l};
    t += s;
  }
  sort(a + 1, a + n + 1);  //确定了吃的顺序

  for (int i = 1; i <= n; i++) {
    int s, e, l;
    s = a[i].s, e = a[i].e, l = a[i].l;
    for (int j = 0; j <= t; j++) {
      int& x = f[i % 2][j];
      x = f[(i - 1) % 2][j];
      if (j >= s) x = max(x, f[(i - 1) % 2][j - s] + max(0, (e - l * (j - s))));
    }
  }
  int res = 0;
  for (int i = 1; i <= t; i++) res = max(res, f[n % 2][i]);
  cout << "Case #" << k << ":"
       << " " << res << endl;
}

int main() {
  int t;
  cin >> t;
  for (int i = 1; i <= t; i++) {
    solve(i);
  }

  return 0;
}
```

##### 金明的预算方案

分组背包问题 由于每组的可选数比较少 所以这么做

```c++
#include <bits/stdc++.h>
#define eb emplace_back
using namespace std;
const int N = 65, M = 32010;
int n, m, idx;
struct Thing {
  int w, v;  // w表示价格*重要度 v表示价格
  Thing(int _w, int _v) { w = _w, v = _v; }
};
vector<Thing> a[N];
int f[M];
int main() {
  cin >> m >> n;
  for (int i = 1; i <= n; i++) {
    int v, p, q;
    cin >> v >> p >> q;
    if (q == 0)
      a[i].eb(v * p, v);
    else
      a[q].eb(v * p, v);
  }
  for (int i = 1; i <= n; i++) {
    if (a[i].empty()) continue;
    for (int j = m; j >= 0; j--) {
      int &x = f[j];
      for (int k = 0; k < 1 << (a[i].size() - 1); k++) {
        int w = a[i][0].w, v = a[i][0].v;//每次枚举选项之前 重新计算w 于v
        for (int t = 0; t < a[i].size() - 1; t++) {
          if (k >> t & 1) {
            w += a[i][t + 1].w;
            v += a[i][t + 1].v;
          }
        }
        if (i == 1 && j == m) cerr << w << " " << v << endl;
        if (j >= v) x = max(x, f[j - v] + w);
      }
    }
  }
  cout << f[m];

  return 0;
}
```

#### 状态机模型

##### 大盗阿福

分为最后一个选了 和 最后一个没选 两个状态

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int a[N];
int f[N][2];
void solve() {
  int n;
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  for (int i = 1; i <= n; i++) {
    f[i][0] = max(f[i - 1][0], f[i - 1][1]);
    f[i][1] = f[i - 1][0] + a[i];
  }
  cout << max(f[n][0], f[n][1]) << endl;
}

int main() {
  ios::sync_with_stdio(0);
  int t;
  cin >> t;
  for (int i = 1; i <= t; i++) {
    solve();
  }

  return 0;
}
```

##### 股票买卖 IV

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10, K = 110;
int n, k;
int a[N], f[N][K][2];
int main() {
  cin >> n >> k;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  memset(f, -0x3f, sizeof f);
  for (int i = 0; i <= n; i++) f[i][0][0] = 0;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= k; j++) {
      f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + a[i]);
      f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - a[i]);
    }
  }
  int res = 0;
  for (int i = 0; i <= k; i++) res = max(res, f[n][i][0]);
  cout << res;

  return 0;
}
```

##### 股票买卖V

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010, INF = 0x3f3f3f3f;

int n;
int w[N];
int f[N][3];

int main()
{
    scanf("%d", &n);

    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);

    f[0][0] = f[0][1] = -INF, f[0][2] = 0;
    for (int i = 1; i <= n; i ++ )
    {
        f[i][0] = max(f[i - 1][0], f[i - 1][2] - w[i]);
        f[i][1] = f[i - 1][0] + w[i];
        f[i][2] = max(f[i - 1][2], f[i - 1][1]);
    }

    printf("%d\n", max(f[n][1], f[n][2]));

    return 0;
}
```

##### 设计密码（难）

状态表示为f[i,j] 第i个字母 当前与模式串匹配到j这个状态 匹配使用kmp TODO:

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 55,MOD=1e9+7;
int n;string str;
int pmt[N],f[N][N];
int main()
{
    cin >> n >> str;
    for(int i=1,j=0;i<str.size();i++){
        while(j&&str[i]!=str[j])j=pmt[j-1];
        if(str[i]==str[j])j++;//j是还没有匹配的下标
        pmt[i]=j;
    }
    f[0][0]=1;
    int m=str.size();
    for (int i = 0; i <=n; i ++ ){
        for (int j = 0; j < m; j ++ ){//枚举匹配到的每个状态 j表示当前还没有匹配的地方
            for(char k='a';k<='z';k++){//第i个数的26种选择
                int u=j;
                while(u && k!=str[u])u=pmt[u-1];//u是待匹配的下标
                if(k==str[u])u++;//对应于k的 状态是u
                if(u<m)f[i+1][u]=(f[i+1][u]+f[i][j])%MOD;
            }
        }
    }
    int res=0;
    for(int i=0;i<m;i++)res=(res+f[n][i])%MOD;
    cout<<res;
}
```

##### 修复DNA（超难）

f[i, j] 前i个字母 当前走到了ac自动机中的第j个节点 所有方案中 最少修改的字母数量 TODO:

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 55, S = 25;
int tr[N * S][4], idx, ne[N * S];
bool dead[N * S];  //表示每个位置会不会死
queue<int> q;
string str;
char s[N * S];
int f[1010][N * S];
int get(char c) {
  if (c == 'A') return 0;
  if (c == 'T') return 1;
  if (c == 'G') return 2;
  return 3;
}
void insert(string &str) {
  int p = 0;
  for (auto i : str) {
    int u = get(i);
    if (!tr[p][u]) tr[p][u] = ++idx;
    p = tr[p][u];
  }
  dead[p] = true;
}

void build() {
  for (int i = 0; i < 4; i++) {
    if (tr[0][i]) q.push(tr[0][i]);
  }
  while (!q.empty()) {
    int t = q.front();
    q.pop();
    for (int i = 0; i < 4; i++) {
      int p = tr[t][i];
      if (!p)
        tr[t][i] = tr[ne[t]][i];
      else {
        ne[p] = tr[ne[t]][i];
        q.push(p);
        dead[p] |= dead[ne[p]];
      }
    }
  }
}

int main() {
  int n, cnt = 0;
  while (cin >> n && n != 0) {
    memset(f, 0x3f, sizeof f);
    memset(tr, 0, sizeof tr);
    memset(ne, 0, sizeof ne);
    memset(dead, 0, sizeof dead);
    idx = 0;
    for (int i = 1; i <= n; i++) {
      cin >> str;
      insert(str);
    }
    build();
    cin >> s + 1;
    int m = strlen(s + 1);
    f[0][0] = 0;
    for (int i = 0; i < m; i++) {  //一共m个待修改的字符
      for (int j = 0; j <= idx; j++) { //j =0 表示什么都没有匹配的头节点
        for (int k = 0; k < 4; k++) {
          int t = get(s[i + 1]) != k;  //如果 k
          int u = tr[j][k];
          if (!dead[u]) f[i + 1][u] = min(f[i + 1][u], f[i][j] + t);
        }
      }
    }
    int res = 0x3f3f3f3f;
    for (int i = 0; i <= idx; i++) res = min(res, f[m][i]);
    if (res >= 0x3f3f3f3f) res = -1;
    cout << "Case " << ++cnt << ": " << res << endl;
  }

  return 0;
}
```

#### 状态压缩模型

##### 小国王

基于棋盘式的状态压缩dp  首先预处理一下 状态数量 

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220404125859207.png" alt="image-20220404125859207" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
#define eb emplace_back

using namespace std;
typedef long long LL;
const int N = 12, K = 10 * 10 + 10, S = 1 << N;
LL f[N][K][S];
bool st[S];
vector<int> states;
int main() {
  int n, m;
  cin >> n >> m;
  for (int i = 0; i < 1 << n; i++) {  //处理i状态是否是合法的
    int cnt = 0;
    st[i] = true;
    for (int j = 0; j < n; j++) {
      if ((i >> j & 1) == 1) {
        if (cnt) st[i] = false;
        cnt++;
      } else
        cnt = 0;
    }
  }
  for (int i = 0; i < 1 << n; i++) {
    if (st[i]) states.eb(i);
  }

  f[0][0][0] = 1;
  for (int i = 1; i <= n + 1; i++) {
    for (int j = 0; j <= m; j++)
      for (auto k1 : states) {  //枚举上一个状态
        int cnt1 = 0, tmp = k1;
        while (tmp) {
          cnt1 += tmp & 1;
          tmp >>= 1;
        }
        if (cnt1 > j) continue;
        for (auto k2 : states) {
          int cnt2 = 0, tmp = k2;
          while (tmp) {
            cnt2 += tmp & 1;
            tmp >>= 1;
          }
          if (j + cnt2 > m) continue;
          if ((k1 & k2) != 0 || !st[k1 | k2]) continue;
          f[i][j + cnt2][k2] += f[i - 1][j][k1];
        }
      }
  }

  LL res = 0;
  for (int i = 0; i < 1 << n; i++) res += f[n][m][i];
  cout << f[n + 1][m][0];

  return 0;
}
```

##### 玉米田

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 14, M = 1 << 12, mod = 1e8;

int n, m;
int w[N];
vector<int> state;
vector<int> head[M];
int f[N][M];

bool check(int state)
{
    for (int i = 0; i + 1 < m; i ++ )
        if ((state >> i & 1) && (state >> i + 1 & 1))
            return false;
    return true;
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j < m; j ++ )
        {
            int t;
            cin >> t;
            w[i] += !t * (1 << j);//w[i]表示 了第i行的不能种的情况 是1的地方不能种
        }

    for (int i = 0; i < 1 << m; i ++ )
        if (check(i))
            state.push_back(i);

    for (int i = 0; i < state.size(); i ++ )
        for (int j = 0; j < state.size(); j ++ )
        {
            int a = state[i], b = state[j];
            if (!(a & b))
                head[i].push_back(j);//预处理a->b是否可行
        }

    f[0][0] = 1;
    for (int i = 1; i <= n + 1; i ++ )
        for (int j = 0; j < state.size(); j ++ )
            if (!(state[j] & w[i]))
                for (int k : head[j])
                    f[i][j] = (f[i][j] + f[i - 1][k]) % mod;

    cout << f[n + 1][0] << endl;

    return 0;
}
```

##### 炮兵阵地

不是求方案数 相容条件变化了 十字形 射程增加 

状态压缩dp可以 先预处理出来每一行可能的状态 数组存放表示状态的数 和 下标之间的关系

```c++
#include <bits/stdc++.h>
#define x first
#define y second
#define eb emplace_back
using namespace std;
const int N = 110, M = 15, S = (1 << 10) + 10;
int n, m;
int g[N], cnt[S], f[2][S][S];  //记录最后两行
vector<int> states;
bool check(int s) {
  int cnt = 5;
  for (int i = 0; i < m; i++) {
    if (s >> i & 1) {
      if (cnt < 2) return false;
      cnt = 0;
    } else
      cnt++;
  }
  return true;
}
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    for (int j = 0; j < m; j++) {
      char c;//注意
      int t;
      cin >> c;
      if (c == 'P')
        t = 1;
      else
        t = 0;
      g[i] += (!t) << j;
    }
  }
  for (int i = 0; i < 1 << m; i++) {
    int tmp = i, ct = 0;
    while (tmp) {
      ct += tmp & 1;
      tmp >>= 1;
    }
    cnt[i] = ct;
    if (check(i)) states.eb(i);
  }

  for (int i = 1; i <= n; i++) {
    for (auto k1 : states) {
      for (auto k2 : states) {
        for (auto k3 : states) {
          int &x = f[i % 2][k2][k3];
          if ((k3 & g[i]) | (k2 & g[i - 1])) continue;
          if ((k1 & k2) | (k1 & k3) | (k2 & k3)) continue;
          x = max(x, f[(i - 1) % 2][k1][k2] + cnt[k3]);
        }
      }
    }
  }

  int res = 0;
  for (auto k1 : states) {
    for (auto k2 : states) {
      res = max(res, f[n % 2][k1][k2]);
    }
  }
  cout << res;

  return 0;
}
```

##### 愤怒的小鸟

重复覆盖模型（愤怒的小鸟）精确覆盖问题（八皇后、数独）；
Dancing Links为最优化解法。

集合类型的状态压缩dp

```c++
bool dfs(int state)//state表示当前哪些列已经被覆盖
{
任选没有覆盖的一列x 枚举所有能覆盖x的抛物线 
}
```

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220405152001900.png" alt="image-20220405152001900" style="zoom: 80%;" />

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

#define x first
#define y second

using namespace std;

typedef pair<double, double> PDD;

const int N = 18, M = 1 << 18;
const double eps = 1e-8;

int n, m;
PDD q[N];//所有的点
int path[N][N];//path[i][j]由 第i个点 和 第j个点 和零点 所确定的抛物线 能划过的点的状态
int f[M];//每个状态所需要的额外的抛物线

int cmp(double x, double y)
{
    if (fabs(x - y) < eps) return 0;
    if (x < y) return -1;
    return 1;
}

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        cin >> n >> m;
        for (int i = 0; i < n; i ++ ) cin >> q[i].x >> q[i].y;

        memset(path, 0, sizeof path);
        for (int i = 0; i < n; i ++ )
        {
            path[i][i] = 1 << i;
            for (int j = 0; j < n; j ++ )
            {
                double x1 = q[i].x, y1 = q[i].y;
                double x2 = q[j].x, y2 = q[j].y;
                if (!cmp(x1, x2)) continue;
                double a = (y1 / x1 - y2 / x2) / (x1 - x2);
                double b = y1 / x1 - a * x1;

                if (cmp(a, 0) >= 0) continue;
                int state = 0;
                for (int k = 0; k < n; k ++ )
                {
                    double x = q[k].x, y = q[k].y;
                    if (!cmp(a * x * x + b * x, y)) state += 1 << k;
                }
                path[i][j] = state;
            }
        }

        memset(f, 0x3f, sizeof f);
        f[0] = 0;
        for (int i = 0; i + 1 < 1 << n; i ++ )//枚举每一个状态
        {
            int x = 0;//x记录当前没有覆盖的第一个点
            for (int j = 0; j < n; j ++ )
                if (!(i >> j & 1))
                {
                    x = j;
                    break;
                }

            for (int j = 0; j < n; j ++ )
                f[i | path[x][j]] = min(f[i | path[x][j]], f[i] + 1);
        }

        cout << f[(1 << n) - 1] << endl;
    }

    return 0;
}
```

##### 宝藏

一个二进制数 i `for(int j=(i-1)&i;j!=0;j=(j-1)&i);` TODO:

#### 区间模型

#####  环形石子合并

解决环形问题方法 开两倍长的数组

```c++
// Problem: 环形石子合并
// Contest: AcWing
// URL: https://www.acwing.com/problem/content/1070/
// Memory Limit: 64 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)
#include <bits/stdc++.h>
using namespace std;
const int N = 410, INF = 0x3f3f3f3f;
int n;
int a[N];
int f[N][N];
int g[N][N];
int sum[N];
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  for (int i = 1; i <= n; i++) {
    a[i + n] = a[i];
  }
  int nn = n * 2;
  for (int i = 1; i <= nn; i++) {
    sum[i] = a[i] + sum[i - 1];
  }

  memset(g, 0x3f, sizeof g);
  for (int i = 1; i <= nn; i++) g[i][i] = 0;
  for (int k = 2; k <= n; k++) {
    for (int l = 1; l <= nn - k + 1; l++) {
      int r = l + k - 1;
      int &x = f[l][r], &y = g[l][r];
      for (int i = l; i < r; i++) {
        x = max(x, f[l][i] + f[i + 1][r] + sum[r] - sum[l - 1]);
        y = min(y, g[l][i] + g[i + 1][r] + sum[r] - sum[l - 1]);
      }
    }
  }
  int resmin = INF, resmax = 0;

  for (int i = 1; i <= nn - n + 1; i++) {
    resmin = min(resmin, g[i][i + n - 1]);
    resmax = max(resmax, f[i][i + n - 1]);
  }
  cout << resmin << endl;
  cout << resmax;

  return 0;
}

```

##### 能量项链

矩阵连乘的环形版本 把所有的系数*2放在一个数组上即可

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 200 + 10;
int n;
int a[N];
int f[N][N];
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
    a[i + n] = a[i];
  }
  for (int len = 3; len <= n + 1; len++) {
    for (int l = 1; l <= 2 * n - len + 1; l++) {
      int r = l + len - 1;
      int &x = f[l][r];
      for (int i = l + 1; i < r; i++) {
        x = max(x, f[l][i] + f[i][r] + a[l] * a[i] * a[r]);
      }
    }
  }
  // cerr << f[4][7] << endl;
  int res = 0;
  for (int i = 1; i <= 2 * n - n - 1 + 1; i++) res = max(res, f[i][i + n]);
  cout << res;

  return 0;
}
```

##### 加分二叉树

考虑**一个区间是一个子树**  **存这个区间的根节点**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 35;
int n, f[N][N], g[N][N];  // f是树的加分总和 g是树的根
struct Node {
  int node_score;
  int l, r;
};
Node a[N];

int solve(int l, int r) {
  if (l == r) return a[l].node_score;
  if (l > r) return 1;
  if (f[l][r] != -1) return f[l][r];
  for (int root = l; root <= r; root++) {
    int left = solve(l, root - 1), right = solve(root + 1, r);
    int &x = f[l][r];
    if (x < left * right + a[root].node_score) {
      x = left * right + a[root].node_score;
      g[l][r] = root;
    }
  }
  return f[l][r];
}

void dfs(int root, int ll, int rr) {
  cout << root << " ";
  int l = root - 1;
  if (l >= ll) {
    int left = g[ll][l];
    dfs(left, ll, l);
  }
  int r = root + 1;
  if (r <= rr) {
    int right = g[r][rr];
    dfs(right, r, rr);
  }
  return;
}
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i].node_score;
  }
  memset(f, -1, sizeof f);
  for (int i = 1; i <= n; i++) f[i][i] = a[i].node_score, g[i][i] = i;

  int res = solve(1, n);
  cout << res << endl;
  int root = g[1][n];
  cerr << g[1][2] << endl;
  dfs(root, 1, n);
  return 0;
}

```

##### 凸多边形的划分

以后再补高精度 TODO: 其实这个不算是环形dp

```c++
#include <bits/stdc++.h>

using namespace std;
typedef int LL;
const int N = 55,INF=0x3f3f3f3f;
int n,a[N];
LL f[N][N];



int main()
{
    cin >> n ;
    for (int i = 1; i <= n; i ++ ){
        cin >> a[i];
    }
    
    for(int len=3;len<=n;len++){
        for(int l=1;l<= n-len+1;l++){
            int r= l+len-1;
            LL &x= f[l][r];
            x=INF;
            for(int mid=l+1;mid<r;mid++){
                x = min(x,f[l][mid]+f[mid][r]+a[l]*a[r]*a[mid]);
            } 
        }
    }
    cout << f[1][n];
}
```

##### 棋盘划分

TODO:

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 15, M = 9;  // M是棋盘大小 N是次数
const double INF = 1e9;

int n, m = 8;
int s[M][M];
double f[M][M][M][M][N];
double X;

int get_sum(int x1, int y1, int x2, int y2) {
  return s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1];
}

double get(int x1, int y1, int x2, int y2) {
  double sum = get_sum(x1, y1, x2, y2) - X;
  return (double)sum * sum / n;//方差
}

double dp(int x1, int y1, int x2, int y2, int k) {
  double &v = f[x1][y1][x2][y2][k];
  if (v >= 0) return v;
  if (k == 1) return v = get(x1, y1, x2, y2);//如果只有一个矩形

  v = INF;
  for (int i = x1; i < x2; i++) {//按编程时候的坐标系
    v = min(v, get(x1, y1, i, y2) + dp(i + 1, y1, x2, y2, k - 1));//按x轴切开
    v = min(v, get(i + 1, y1, x2, y2) + dp(x1, y1, i, y2, k - 1));
  }

  for (int i = y1; i < y2; i++) {
    v = min(v, get(x1, y1, x2, i) + dp(x1, i + 1, x2, y2, k - 1));
    v = min(v, get(x1, i + 1, x2, y2) + dp(x1, y1, x2, i, k - 1));
  }

  return v;
}

int main() {
  cin >> n;
  for (int i = 1; i <= m; i++)
    for (int j = 1; j <= m; j++) {
      cin >> s[i][j];
      s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
    }

  X = (double)s[m][m] / n;
  cerr << X;
  memset(f, -1, sizeof f);
  printf("%.3lf\n", sqrt(dp(1, 1, 8, 8, n)));

  return 0;
}
```

#### 树形模型

##### 树的最长路径

**树的直径 最长的一条路径** 

任取一点作为起点 找到距离该店最远的一点u

再找到距离u最远的一点v u和v 之间的路径就是一条直径 DFS **BFS**

```c++
#include <bits/stdc++.h>
#define x first
#define y second
#define eb emplace_back
typedef long long LL;
using namespace std;
const int N = 1e4 + 10;
struct Edge {
  int to, w;
  Edge() {}
  Edge(int _to, int _w) { to = _to, w = _w; }
};
vector<Edge> edges[N];
int n;
int ans;
int dfs(int u, int fa) {
  int dist = 0;
  int d1 = 0, d2 = 0;

  for (auto t : edges[u]) {
    if (t.to == fa) continue;
    int d = dfs(t.to, u) + t.w;
    if (t.to == 6) cerr << t.to << " " << t.w << " " << u << endl;
    dist = max(dist, d);
    if (d >= d1) {
      d2 = d1;
      d1 = d;
    } else if (d > d2)
      d2 = d;
  }
  ans = max(ans, d1 + d2);//d1 + d2表示 挂到uz
  return dist;
}

int main() {
  cin >> n;
  for (int i = 1; i <= n - 1; i++) {
    int a, b, c;
    cin >> a >> b >> c;
    edges[a].eb(b, c);
    edges[b].eb(a, c);
  }
  dfs(1, 0);
  cerr << dfs(6, 1) << endl;
  cout << ans;

  return 0;
}
```

##### 树的中心

求出每个点到其他所有点的最远距离

最远距离有两种 一种从子节点开始 另一种是从父节点开始

```c++
#include <bits/stdc++.h>
#define x first
#define y second
#define eb emplace_back
using namespace std;
const int N = 1e4 + 10, INF = 0x3f3f3f3f;
struct Edge {
  int to, w;
  Edge(int _to, int _w) : to(_to), w(_w) {}
};
vector<Edge> edges[N];
int d1[N], d2[N], p1[N], p2[N];  // p1[i] 记录i节点的最长向下路径的子节点
int up[N];
int n;  //树的边只有节点数-1

int dfs_d(int u, int fa) {
  d1[u] = d2[u] = 0;  //因为权值大于等于0
  for (auto item : edges[u]) {
    int to = item.to, w = item.w;
    if (to == fa) continue;
    int d = dfs_d(to, u) + w;
    if (d >= d1[u]) {
      d2[u] = d1[u], p2[u] = p1[u];
      d1[u] = d, p1[u] = to;
    } else if (d > d2[u]) {
      d2[u] = d, p2[u] = to;
    }
  }
  if (d1[u] == -INF) d1[u] = d2[u] = 0;
  return d1[u];
}
int dfs_u(int u, int fa) {  //
  for (auto item : edges[u]) {
    int to = item.to, w = item.w;
    if (to == fa) continue;
    if (to != p1[u]) {
      up[to] = max(up[u], d1[u]) + w;
    } else {
      up[to] = max(up[u], d2[u]) + w;
    }
    dfs_u(to, u);
  }
  return 0;
}

int main() {
  cin >> n;
  for (int i = 1; i <= n - 1; i++) {
    int a, b, c;
    cin >> a >> b >> c;
    edges[a].eb(b, c), edges[b].eb(a, c);
  }
  dfs_d(1, 0);
  up[1] = 0;  //假设1号点是根节点
  dfs_u(1, 0);
  int res = INF;

  for (int i = 1; i <= n; i++) res = min(res, max(d1[i], up[i]));
  cout << res;
  return 0;
}
```

##### 数字转换

求 1-N 中 每个数的 约数之和 可以使用类似筛法的方法 枚举约数 在枚举约数的倍数

题中的节点和边 会构成一棵树 

```c++
#include <bits/stdc++.h>
#define x first
#define y second
#define eb emplace_back
using namespace std;
typedef long long LL;
const int N = 5e4 + 10, INF = 0x3f3f3f3f;
vector<int> edges[N];
bool st[N];
LL sum[N];  // sum[i]表示i节点的约数之和
int n, ans;
int dfs(int u) {  //以u为节点开始搜索
  int d1 = 0, d2 = 0;
  for (auto to : edges[u]) {
    int d = dfs(to) + 1;
    if (d >= d1)
      d2 = d1, d1 = d;
    else if (d > d2)
      d2 = d;
  }
  ans = max(ans, d1 + d2);
  return d1;
}
int main() {
  cin >> n;
  for (int i = 1; i <= n / 2; i++) {  //枚举约数
    for (int j = 2; j <= n / i; j++) {
      sum[i * j] += i;
    }
  }
  for (int i = 2; i <= n; i++) {
    if (sum[i] < i) edges[sum[i]].eb(i);  //有向树
  }

  for (int i = 1; i <= n; i++) {
    if (!st[i]) dfs(i);
  }

  cout << ans;
  return 0;
}
```

##### 二叉苹果树

和有依赖的背包问题一致

```c++
#include <bits/stdc++.h>
#define x first
#define y second
#define eb emplace_back
using namespace std;
const int N = 110;
typedef long long LL;
LL f[N][N];
int n, q, a[N];
struct Edge {
  int to, w;
  Edge(int _to, int _w) : to(_to), w(_w) {}
};
vector<Edge> edges[N];

void dfs(int u, int fa) {       //获得u节点的各个体积下的值
  for (auto item : edges[u]) {  
    int to = item.to, w = item.w;
    if (to == fa) continue;
    dfs(to, u);
    for (int j = q; j >= 0; j--) {//考虑在u这个节点下选取j个树枝
      for (int k = 0; k <= j - 1; k++) {//子树选取的数值一定小于j
        if (j > k) {
          LL& x = f[u][j];
          x = max(x, f[u][j - k - 1] + f[to][k] + w);
        }
      }
    }
  }
}

int main() {
  cin >> n >> q;
  for (int i = 1; i <= n - 1; i++) {
    int a, b, c;
    cin >> a >> b >> c;
    edges[a].eb(b, c);//输入时 虽然知道根节点是谁 但是不知道边的方向
    edges[b].eb(a, c);
  }
  dfs(1, 0);
  cout << f[1][q];
  return 0;
}
```

##### 战略游戏

最大独立集 没有上司的舞会 每条边最多只选一个点 求最大权值

战略游戏 每条边上至少选择一个点 求最小权值  覆盖每个边

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220408213049617.png" alt="image-20220408213049617" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
#define x first
#define y second
#define eb emplace_back
using namespace std;

const int N = 2e3, INF = 0x3f3f3f3f;
vector<int> edges[N];
int n, f[N][2];
bool st[N];
void dfs(int u, int fa) {
  int &x = f[u][0], &y = f[u][1] = 1;
  for (auto to : edges[u]) {
    if (to == fa) continue;
    dfs(to, u);
    x += f[to][1];
    y += min(f[to][0], f[to][1]);
  }
}

void solve() {
  memset(f, 0, sizeof f);
  memset(st, 0, sizeof st);
  for (int i = 0; i <= n - 1; i++) edges[i].clear();
  for (int i = 0; i <= n - 1; i++) {
    int idx, num;
    scanf("%d:(%d)", &idx, &num);
    for (int j = 1; j <= num; j++) {
      int to;
      cin >> to;
      st[to] = true;

      edges[idx].eb(to);
    }
  }
  int root = 0;
  while (st[root]) root++;
  dfs(root, -1);
  int res = min(f[root][0], f[root][1]);
  cout << res << endl;
}
int main() {
  while (cin >> n) {
    solve();
  }

  return 0;
}
```

##### 皇宫看守

覆盖每个点

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220409133410298.png" alt="image-20220409133410298" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
#define x first
#define y second
#define eb emplace_back
using namespace std;
const int N = 2e3, INF = 0x3f3f3f3f;
int n, w[N], f[N][3];
/*
f[i][0]表示以i为根的子树被解决了 i依赖于父节点 i节点没有放
f[i][1]表示以i为根的子树被解决了 i依赖于子节点 i节点没有放
f[i][2]表示以i为根的子树被解决了 i依赖于自己
*/
vector<int> edges[N];
bool st[N];
void dfs(int u) {
  int &x = f[u][0] = 0, &y = f[u][1] = INF, &z = f[u][2] = w[u];
  for (auto to : edges[u]) {
    dfs(to);
    x += min({f[to][1], f[to][2]});
    z += min({f[to][0], f[to][1], f[to][2]});
  }
  for (auto to1 : edges[u]) {
    int candi = f[to1][2];
    for (auto to2 : edges[u]) {
      if (to2 == to1) continue;
      candi += min({f[to2][1], f[to2][2]});
    }
    y = min(y, candi);
  }
}

int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    int idx, num;
    cin >> idx >> w[idx] >> num;
    for (int j = 1; j <= num; j++) {
      int to;
      cin >> to;
      st[to] = true;
      edges[idx].eb(to);  //如果是单向的边 那么需要找到root
    }
  }
  int root = 1;
  while (st[root]) root++;
  dfs(root);
  int res = min(f[root][1], f[root][2]);
  cout << res;
  return 0;
}
```

#### 数位模型

技巧1：问[X,Y]之中符合性质数的个数 答案为 f(Y)-f(X-1)

技巧2：树的方式来考虑 （分类讨论） 预处理就是一个别的dp问题

##### 度的数量

求01组成的数的个数

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220409195955255.png" alt="image-20220409195955255" style="zoom:80%;" />

```c++
#include<bits/stdc++.h>
#define eb emplace_back
using namespace std;
typedef long long LL;
const int N=55;
LL c[N][N];//预处理组合数
int l,r,k,b;

int dp(int n){
    if(!n)return 0;
	vector<int> nums;
	while(n)nums.eb(n%b),n/=b;
	
	int res=0,last=0;//last记录有过多少个1
	for(int i=nums.size()-1;i>=0;i--){
	    int x=nums[i];
	    if(x){//如果当前位大于等于1 那么
	        if(k>=last)res+=c[i][k-last];//当前位是0 从剩下的i位中选取k-last个1
	        if(x>1){
	            if(k>=last+1)res+=c[i][k-last-1];
	            break;//如果当前位大于1的话 我们在27行就枚举完了所有的可能
	        }else {
	            last++;
	            if(last>k)break;//如果当前分支的1的数目超过上限 可以直接return
	        }
	    }
	    if(!i && k==last)res++;
	}
	return res;
}

int main(){
	cin>>l>>r>>k>>b;
	
	for(int i=0;i<N;i++){
		for(int j=0;j<=i;j++){
			if(!j)c[i][j]=1;
			else c[i][j]=c[i-1][j-1]+c[i-1][j];
		}
	}
	
	cout<<dp(r)-dp(l-1);
	
	return 0;
}
```

##### 数字游戏

求不降数 关于前导0的问题 加上前导0并不影响性质 所以可以加

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220409211244739.png" alt="image-20220409211244739" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
#define eb emplace_back
using namespace std;
typedef long long LL;
const int N = 20;
int l, r;
LL f[N][N];  // f[i][j]表示长度位i且首位数字是j的不降数的个数

LL dp(int n) {
  if (!n) return 1;
  vector<int> nums;
  while (n) nums.eb(n % 10), n /= 10;

  LL res = 0, last = 0;
  for (int i = nums.size() - 1; i >= 0; i--) {
    int x = nums[i];
    for (int j = last; j < x; j++) res += f[i + 1][j];//这里f[i+1][0]并不会导致重复 因为首位是0d
    if (x < last) break;
    last = x;

    if (!i) res++;
  }
  return res;
}

int main() {
  for (int i = 0; i <= 11; i++) f[1][i] = 1;
  for (int i = 2; i <= N; i++) {
    for (int j = 0; j <= 9; j++) {
      for (int k = j; k <= 9; k++) {
        f[i][j] += f[i - 1][k];
      }
    }
  }
  while (cin >> l >> r) {
    cout << dp(r) - dp(l - 1) << endl;
  }

  return 0;
}
```

##### Windy数

预处理时 不用管前导0 在数位dp的时候 在意位数即可 对于数位较小的进行额外的枚举即可

```c++
#include <bits/stdc++.h>
#define x first
#define y second
#define eb emplace_back
using namespace std;
const int N = 20;
int l, r, f[N][N];

int dp(int n) {
  if (!n) return 0;
  vector<int> nums;
  while (n) nums.eb(n % 10), n /= 10;

  int res = 0, last = -1;
  for (int i = nums.size() - 1; i >= 0; i--) {
    int x = nums[i];
    for (int j = 0; j < x; j++) {
      if (abs(j - last) >= 2) res += f[i + 1][j];
    }
    if (abs(x - last) >= 2)
      last = x;
    else
      break;
    if (!i) res++;
  }
  //特殊处理有前导0的数 也就是数位不够的数
  for (int i = 1; i < nums.size(); i++) {  //是n-1到1位数
    for (int j = 1; j <= 9; j++) res += f[i][j];
  }
  return res;
}
int main() {
  cin >> l >> r;
  // f[2][2] 20 +=f[1][0] f[2][4] +=f[1][4]
  for (int i = 0; i <= 9; i++) f[1][i] = 1;
  for (int i = 2; i <= 20; i++) {
    for (int j = 0; j <= 9; j++) {  //求f[i][j]
      for (int k = 0; k <= 9; k++) {
        if (abs(k - j) >= 2) f[i][j] += f[i - 1][k];
      }
    }
  }

  cout << dp(r) - dp(l - 1);
  return 0;
}
```

##### 数字游戏Ⅱ

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220410131913652.png" alt="image-20220410131913652" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
#define x first
#define y second
#define eb emplace_back
using namespace std;
typedef long long LL;
const int N = 20, M = 110;
int l, r, mod;
LL f[N][N][M];

LL dp(int n) {
  if (!n) return 1;

  vector<int> nums;
  while (n) nums.eb(n % 10), n /= 10;

  LL res = 0, last = 0;
  for (int i = nums.size() - 1; i >= 0; i--) {
    int x = nums[i];
    for (int j = 0; j < x; j++) {
      res += f[i + 1][j][(mod - last) % mod];
    }
    last += x;
    last %= mod;
    if (!i && last == 0) res++;
  }
  return res;
}

void solve() {
  memset(f, 0, sizeof f);
  for (int i = 0; i <= 9; i++) f[1][i][i % mod] = 1;
  for (int i = 2; i < N; i++) {
    for (int j = 0; j <= 9; j++) {
      for (int k = 0; k < mod; k++) {
        for (int x = 0; x <= 9; x++) {
          f[i][j][k] += f[i - 1][x][((k - j) % mod + mod) % mod];
        }
      }
    }
  }

  cout << dp(r) - dp(l - 1) << endl;
}

int main() {
  while (cin >> l >> r >> mod) {
    solve();
  }

  return 0;
}

```

##### 不要62

可以向设计密码进行拓展 

```c++
#include <bits/stdc++.h>
#define x first
#define y second
#define eb emplace_back
using namespace std;
const int N = 15;
typedef long long LL;
LL f[N][N];
int l, r;

LL dp(int n) {
  if (!n) return 1;

  vector<int> nums;
  while (n) nums.eb(n % 10), n /= 10;

  LL res = 0, last = -1;
  for (int i = nums.size() - 1; i >= 0; i--) {
    int x = nums[i];
    for (int j = 0; j < x; j++) {
      if (j == 4) continue;
      if (last == 6 && j == 2) continue;
      res += f[i + 1][j];
    }
    if (x == 4) break;
    if (last == 6 && x == 2)
      break;
    else
      last = x;
    if (!i && x != 4) res++;
  }

  return res;
}

void solve() { cout << dp(r) - dp(l - 1) << endl; }

int main() {
    //预处理f[i][j]串长度是i 首字符是j 同时满足题目要求和可以有前导0（因为有前导0 的只会被加一次）
  for (int i = 0; i <= 9; i++)
    if (i != 4) f[1][i] = 1;
  for (int i = 2; i < N; i++) {
    for (int j = 0; j <= 9; j++) {  // f[i][j]
      if (j == 4) continue;
      for (int k = 0; k <= 9; k++) {
        if (j == 6 && k == 2) continue;
        f[i][j] += f[i - 1][k];
      }
    }
  }
  
  while (cin >> l >> r) {
    if (l == r && r == 0) break;
    solve();
  }

  return 0;
}
```

##### 恨7不成妻

想求一堆数字的平方和的话 需要求 数字的个数，数字的和 数字的平方和

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220410192554329.png" alt="image-20220410192554329" style="zoom:80%;" />

```c++
#include <algorithm>
#include <cstring>
#include <iostream>
#include <vector>

using namespace std;

typedef long long LL;

const LL N = 20, MOD = 1e9 + 7;

struct F {
  LL s0, s1, s2;
} f[N][10][7][7];  // f[i][j][a][b]表示串长度是i 首位数字是j a是各位数字和的余数
                   // b是值的余数

LL power7[N], power9[N];

LL mod(LL x, LL y) { return (x % y + y) % y; }

void init() {
  for (LL i = 0; i <= 9; i++) {
    if (i == 7) continue;
    f[1][i][i % 7][i % 7] = {1, i, i * i};
  }

  LL power = 10;
  for (LL i = 2; i < N; i++, power *= 10)
    for (LL j = 0; j <= 9; j++) {
      if (j == 7) continue;
      for (LL a = 0; a < 7; a++)
        for (LL b = 0; b < 7; b++)
          for (LL k = 0; k <= 9; k++) {
            if (k == 7) continue;
            auto &v1 = f[i][j][a][b],
                 &v2 = f[i - 1][k][mod(a - j * power, 7)][mod(b - j, 7)];
            v1.s0 = mod(v1.s0 + v2.s0, MOD);
            v1.s1 = mod(v1.s1 + v2.s1 + j * (power % MOD) % MOD * v2.s0, MOD);
            v1.s2 = mod(
                v1.s2 +
                    j * j * (power % MOD) % MOD * (power % MOD) % MOD * v2.s0 +
                    v2.s2 + 2 * j * power % MOD * v2.s1,
                MOD);
          }
    }

  power7[0] = 1;
  for (LL i = 1; i < N; i++) power7[i] = power7[i - 1] * 10 % 7;

  power9[0] = 1;
  for (LL i = 1; i < N; i++) power9[i] = power9[i - 1] * 10 % MOD;
}

F get(LL i, LL j, LL a, LL b) {
  LL s0 = 0, s1 = 0, s2 = 0;
  for (LL x = 0; x < 7; x++)
    for (LL y = 0; y < 7; y++)
      if (x != a && y != b) {
        auto v = f[i][j][x][y];
        s0 = (s0 + v.s0) % MOD;
        s1 = (s1 + v.s1) % MOD;
        s2 = (s2 + v.s2) % MOD;
      }
  return {s0, s1, s2};
}

LL dp(LL n) {
  if (!n) return 0;

  LL backup_n = n % MOD;
  vector<LL> nums;
  while (n) nums.push_back(n % 10), n /= 10;

  LL res = 0;
  LL last_a = 0, last_b = 0;
  for (LL i = nums.size() - 1; i >= 0; i--) {
    LL x = nums[i];
    for (LL j = 0; j < x; j++) {
      if (j == 7) continue;
      LL a = mod(-last_a * power7[i + 1], 7);
      LL b = mod(-last_b, 7);
      auto v = get(i + 1, j, a, b);
      res = mod(res +
                    (last_a % MOD) * (last_a % MOD) % MOD * power9[i + 1] %
                        MOD * power9[i + 1] % MOD * v.s0 % MOD +
                    v.s2 + 2 * last_a % MOD * power9[i + 1] % MOD * v.s1,
                MOD);
    }

    if (x == 7) break;
    last_a = last_a * 10 + x;
    last_b += x;

    if (!i && last_a % 7 && last_b % 7) res = (res + backup_n * backup_n) % MOD;
  }

  return res;
}

int main() {
  LL T;
  cin >> T;

  init();

  while (T--) {
    LL l, r;
    cin >> l >> r;
    cout << mod(dp(r) - dp(l - 1), MOD) << endl;
  }

  return 0;
}

```



#### 单调队列优化模型

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220410220359594.png" alt="image-20220410220359594" style="zoom:67%;" />如果集合较大或者是无限 需要先将集合变成有限的（使用一些性质作证明）

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220410220827417.png" alt="image-20220410220827417" style="zoom:80%;" />

##### 最大子序和

求得m长的区间中 最小的前缀和

假设k是子串的终点 那么我们需要从[k-m,k-1]这m个数中找到最小值

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 3e5 + 10,INF=0x3f3f3f3f;
int n, m, a[N];
LL sum[N];
LL ans = -INF;
int main() {
  ios::sync_with_stdio(0);
  cin >> n >> m;
  for (int i = 1; i <= n; i++) cin >> a[i];
  for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i];
  deque<int> Q;  // 存储的是编号 k是区间长度 V中存放着原序列
  Q.push_back(0);//对应于终点为1的最小值
  for (int i = 1; i <= n; i++) {
    if (!Q.empty() && Q.front() < i - m)//当前值i 但是我们寻找的区间左端点是i-m
      Q.pop_front();  //
    ans = max(ans, sum[i] - sum[Q.front()]); //找到了最小值
    while (!Q.empty() && sum[Q.back()] > sum[i])
      Q.pop_back();  // 比新生弱的当场退役（求区间最小值把这里改成>即可）
     Q.push_back(i);
  }
  cout << ans;
  return 0;
}
```

##### 修剪草坪

转化的思路，题目要求 最多连续选k个使效率最大

可以转化为 每k + 1个里必须不选 1 个，使不选的总效率最小，最后用总效率减去不选的效率即可

f[i]表示不选第i个的最小不选效率，从前k + 1个里转移即可。

直接计算

f[i]表示使用前i个的最大效率 如果第i个不选 那么效率就是f[i-1] 如果选的话 那么考虑与i相连的最小的编号为j 那么f[j-2] + s[i]-s[j-1]就是最大效率 由于f[j-2]-s[j-1] + s[i] 中s[i]是固定的 相当于找到一个 j   i-j+1>k  i+1-k >j   i-k>j-1时非法

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 1e5 + 10;
LL n, m, a[N];
LL f[N];
deque<int> Q;
LL get(int j) {
  if (j == 0) return 0;
  return -a[j] + f[j - 1];
}
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    scanf("%d", &a[i]);
    a[i] += a[i - 1];
  }
  f[0] = 0;
  Q.push_back(0);
  for (int i = 1; i <= n; i++) {
    while (!Q.empty() && Q.front() < i - m)
      Q.pop_front();  //队列中放着边界外的哨兵下标
    f[i] = f[i - 1];
    f[i] = max(f[i], a[i] + get(Q.front()));
    while (!Q.empty() && get(Q.back()) < get(i)) Q.pop_back();
    Q.push_back(i);
  }
  cout << f[n];
  return 0;
}
```

##### 旅行问题

转化为 某一个区间上的前缀和 都大于0 求这个区间上的最小值

a[i]表示如果从第i个节点走到下一个节点 之后剩下的油（只在第i个节点加油）这样只要区间中的每一个点的值都大于0即可

使用s[] 来求 从i+1 到 i+n的所有点的局部的区间和的最小值 考虑到s[i]是一定的（i+1是起点）那么就找i+j 使用s[i+j]最小

最小的节点的值是s[i+j]-s[i]

对于逆时针来说 需要求的是从 i-1 i-2 ... i-n 这个区间上的局部的前缀和的最小值

```c++
// Problem: 旅行问题
// Contest: AcWing
// URL: https://www.acwing.com/problem/content/1090/
// Memory Limit: 64 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)
#include <bits/stdc++.h>
using namespace std;
const int N = 2e6 + 10;
typedef long long LL;
int n, o[N], d[N];
LL s[N];
bool ans[N];
int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++) {
    int o_, d_;
    scanf("%d %d", &o_, &d_);
    o[i] = o[i + n] = o_;
    d[i] = d[i + n] = d_;
  }
  for (int i = 1; i <= 2 * n; i++) {
    s[i] += o[i] - d[i];
    s[i] += s[i - 1];
  }
  deque<int> Q;
  for (int i = 2 * n; i >= 0; i--) {         //枚举起点
    while (!Q.empty() && Q.front() > i + n)  //  i i+1 ... i+n
      Q.pop_front();  //找到i+1 - i+n这个闭区间中的最小值 i+1
                      // i+2一直到i+n这n个点的顺序遍历
    if (i < n) {      // Q.front的值是i+1 i+n中最小的
      if (s[Q.front()] - s[i] >= 0)
        ans[i + 1] = true;  //最小的从i+1开始的前缀和 如果非负
    }
    //把第i项加入队列
    while (!Q.empty() && s[Q.back()] >= s[i]) Q.pop_back();
    Q.push_back(i);
  }
  Q.clear();
  //反向求一遍距离
  d[0] = d[n];  // d[0]是给1用的 表示n到1的距离
  for (int i = 1; i <= n; i++) s[i] = s[i + n] = o[i] - d[i - 1];
  for (int i = 1; i <= n * 2; i++) s[i] += s[i - 1];

  for (int i = 1; i <= 2 * n; i++) {         //枚举起点
    while (!Q.empty() && Q.front() < i - n)  //  i-n   ... i-1  i
      Q.pop_front();  //找到i - i+n这个闭区间中的最小值 i+1
                      // i+2一直到i+n这n个点的顺序遍历
    if (i > n) {
      if (s[i] - s[Q.front()] >= 0) ans[i - n] = true;
    }
    while (!Q.empty() && s[Q.back()] <= s[i]) Q.pop_back();
    Q.push_back(i);
  }

  for (int i = 1; i <= n; i++) {
    if (ans[i])
      puts("TAK");
    else
      puts("NIE");
  }

  return 0;
}

```

##### 烽火传递

每m个烽火台就要有一个被选中 f[i]是第i个烽火台被选中 并且 1-i中状态都是合法的

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10, INF = 0x3f3f3f3f;
typedef long long LL;
int n, m, a[N];
LL f[N];

int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
  f[1] = a[1];
  deque<int> Q;
  Q.push_back(0);
  for (int i = 1; i <= n; i++) {
    while (!Q.empty() && Q.front() < i - m) Q.pop_front();
    f[i] = a[i] + f[Q.front()];
    while (!Q.empty() && f[Q.back()] > f[i]) Q.pop_back();
    Q.push_back(i);
  }

  LL res = INF;
  for (int i = n; i >= n - m + 1; i--) res = min(res, f[i]);
  cout << res;

  return 0;
}
```

##### 绿色通道

二分 潜在的最短长度 + 单调队列验证

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 5e4 + 10, INF = 0x3f3f3f3f;
int n, t, a[N];
LL f[N];
bool check(int m) {  // m+1个中至少有一个
  memset(f, 0x3f, sizeof f);
  deque<int> Q;
  Q.push_back(0);
  f[0] = 0;
  for (int i = 1; i <= n; i++) {
    while (!Q.empty() && Q.front() < i - m - 1)  //超出区间
      Q.pop_front();
    f[i] = min(f[i], a[i] + f[Q.front()]);
    while (!Q.empty() && f[Q.back()] >= f[i])  //大的数不要
      Q.pop_back();
    Q.push_back(i);
  }

  LL res = INF;
  for (int i = n; i >= n - m; i--) res = min(res, f[i]);
  return res <= t;
}

int main() {
  cin >> n >> t;
  for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
  int l = 0,
      r = n;  //二分最长的空题段 0就是全做了 n就是都没做
  while (l < r) {
    int mid = l + (r - l) / 2;
    if (check(mid))
      r = mid;
    else
      l = mid + 1;
  }
  cout << l;

  return 0;
}

```

##### 理想的正方形

二维求最值 先做行的最值 把一行的最大值压缩到一个的值

```c++
// Problem: 理想的正方形
// Contest: AcWing
// URL: https://www.acwing.com/problem/content/1093/
// Memory Limit: 64 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)
#include <bits/stdc++.h>
using namespace std;
const int N = 1010, INF = 0x3f3f3f3f;
int a, b, n, m[N][N];
int row_min[N][N];  // row_min[i]表示以i为结尾的 长度为n的窗口的最小值
int row_max[N][N];
void get_min(int a[], int b[], int tot) {
  // a表示待处理的串 b表示答案 tot表示串长度，区间长度为n是全局变量
  deque<int> Q;
  for (int i = 1; i <= tot; i++) {
    while (!Q.empty() && Q.front() < i - n + 1) Q.pop_front();
    while (!Q.empty() && a[Q.back()] >= a[i]) Q.pop_back();
    Q.push_back(i);
    b[i] = a[Q.front()];
  }
}
void get_max(int a[], int b[], int tot) {
  // a表示待处理的串 b表示答案 tot表示串长度，区间长度为n是全局变量
  deque<int> Q;
  for (int i = 1; i <= tot; i++) {
    while (!Q.empty() && Q.front() < i - n + 1) Q.pop_front();
    while (!Q.empty() && a[Q.back()] <= a[i]) Q.pop_back();
    Q.push_back(i);
    b[i] = a[Q.front()];
  }
}

int main() {
  cin >> a >> b >> n;
  for (int i = 1; i <= a; i++) {
    for (int j = 1; j <= b; j++) {
      scanf("%d", &m[i][j]);
    }
  }
  for (int i = 1; i <= a; i++) {
    get_min(m[i], row_min[i], b);  //第i行中每个区间的最小数
    get_max(m[i], row_max[i], b);  //第i行中每个区间的最大数
  }

  int col[N], res = 1e9;
  int maxn[N], minn[N];           //一列
  for (int j = n; j <= b; j++) {  //考虑第j列
    for (int i = 1; i <= a; i++) {
      col[i] = row_min[i][j];
    }
    get_min(col, minn, a);

    for (int i = 1; i <= a; i++) {
      col[i] = row_max[i][j];
    }
    get_max(col, maxn, a);

    for (int i = n; i <= a; i++) {
      res = min(res, maxn[i] - minn[i]);
    }
  }
  cout << res;

  return 0;
}
```

#### 斜率优化模型

##### 任务安排1

n个任务排成序列 分成若干批

把花费重新整合 讲s开机时间的影响 整合到一个点上

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220413153458343.png" alt="image-20220413153458343" style="zoom:67%;" />

分析

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 5010;
typedef long long LL;
LL n, s, t[N], c[N], sumt[N], sumc[N], f[N];
int main() {
    cin >> n >> s;
    for (int i = 1; i <= n; i++) {
        scanf("%d %d", &t[i], &c[i]);
        sumt[i] = sumt[i - 1] + t[i];
        sumc[i] = sumc[i - 1] + c[i];
    }
    memset(f, 0x3f, sizeof f);
    f[0] = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            f[i] = min(
                f[i], f[j] + sumt[i] * (sumc[i] - sumc[j]) +
                          s * (sumc[n] - sumc[j]));
        }
    }
    cout << f[n];

    return 0;
}
```

##### 任务安排2

f[i]的表达式拆成 只含i的式子 和 包含j的式子。包含j的因子是变量 我们需要求得argmin j

只维护凸包的下边界 f[j] 和s+sumt[j]是确定了 线段上方的点都可以删掉

如何求凸包 先把所有点按横坐标排序 之后把点一个个入队 如果新入队的元素 不能满足斜率单增 那么弹出队尾元素，所有点最多出队进队一次，O(n)复杂度

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220413194934428.png" alt="image-20220413194934428" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10, INF = 0x3f3f3f3f;
typedef long long LL;
LL n, s, sumt[N], sumc[N], f[N];
int main() {
    cin >> n >> s;
    for (int i = 1; i <= n; i++) {
        scanf("%lld %lld", &sumt[i], &sumc[i]);
        sumt[i] += sumt[i - 1];
        sumc[i] += sumc[i - 1];
    }
    memset(f, 0x3f, sizeof f);
    f[0] = 0;
    deque<int> Q;
    Q.push_back(0);
    for (int i = 1; i <= n; i++) {
        while (Q.size() > 1 &&
               (f[Q[1]] - f[Q[0]]) <=
                   (s + sumt[i]) *
                       (sumc[Q[1]] - sumc[Q[0]]))
            Q.pop_front();  //斜率小于要优化的k那么直接弹出
        
        f[i] = f[Q[0]] - (sumt[i] + s) * sumc[Q[0]] +
               sumt[i] * sumc[i] + s * sumc[n];

        while (Q.size() > 1 &&
               (f[*(Q.rbegin())] - f[*(Q.rbegin() + 1)]) *
                       (sumc[i] - sumc[*(Q.rbegin())]) >=
                   (f[i] - f[*(Q.rbegin())]) *
                       (sumc[*(Q.rbegin())] -
                        sumc[*(Q.rbegin() + 1)]))
            Q.pop_back();//要维护凸包斜率的单调性
        
        Q.push_back(i);
    }
    for (int i = 1; i <= n; i++) cerr << f[i] << endl;
    cout << f[n];
    return 0;
}
```

##### 任务安排3

待优化的线的斜率 不再单调了，查询的时候需要二分 插入的时候仍然是单调的 横坐标单调增

巨大的坑在于 比较两个点斜率的时候 确保交换乘的数大于0 不然不等式判断的就是错的

```c++
#pragma GCC optimize(2)

#include <bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10, INF = 0x3f3f3f3f;
typedef long long LL;
LL n, s, sumt[N], sumc[N], f[N];
deque<int> Q;
bool check(int i, LL k) {
    // i的斜率大于等于k 返回真
    // if (i == Q.size() - 1) return false;
    if (f[Q[i + 1]] - f[Q[i]] >=
        k * (sumc[Q[i + 1]] - sumc[Q[i]]))
        return true;
    return false;
}

int main() {
    cin >> n >> s;
    for (int i = 1; i <= n; i++) {
        scanf("%lld %lld", &sumt[i], &sumc[i]);
        sumt[i] += sumt[i - 1];
        sumc[i] += sumc[i - 1];
    }
    memset(f, 0x3f, sizeof f);
    f[0] = 0;

    Q.push_back(0);
    for (int i = 1; i <= n; i++) {
        int l = 0, r = Q.size() - 1;

        while (l < r) {
            int mid = l + (r - l) / 2;
            if (check(mid, (s + sumt[i])))
                r = mid;
            else
                l = mid + 1;
        }
        // cerr << i << " " << l << " " << Q.size() - 1
        // << endl;
        f[i] = f[Q[l]] - (sumt[i] + s) * sumc[Q[l]] +
               sumt[i] * sumc[i] + s * sumc[n];

        while (Q.size() > 1 &&
               (double)(f[*(Q.rbegin())] - f[*(Q.rbegin() + 1)]) *
                       (sumc[i] - sumc[*(Q.rbegin())]) >=
                   (double)(f[i] - f[*(Q.rbegin())]) *
                       (sumc[*(Q.rbegin())] -
                        sumc[*(Q.rbegin() + 1)]))
            Q.pop_back();
        Q.push_back(i);
    }
    cout << f[n];
    return 0;
}
```



### 杂题

##### 鸡蛋的硬度（DP）

如果鸡蛋个数无限 尝试的次数是logn 但是鸡蛋个数受限

条件 m个鸡蛋 n层楼

最优化 扔的次数 f[i] [j] i层楼 j个鸡蛋 仍的次数 或者 f[i] [j] 扔i次 j个鸡蛋 可以的层数

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=110,M=15,INF=0x3f3f3f3f;
int n,m,f[N][M];
int solve(int n,int m){//n是楼高 m是鸡蛋数
    if(f[n][m]!=-1)return f[n][m];
    if(n==0)return f[n][m]=n;
    if(m==1)return f[n][m]=n;
    int res = INF;
    for (int i = 1; i <= n; i ++ ){
        int rest=max(solve(i-1,m-1)+1,solve(n-i,m)+1);
        res=min(res,rest);
    }
    return f[n][m]=res;
}
int main()
{
    memset(f, -1, sizeof f);
    while(scanf("%d%d",&n,&m)==2){
        cout << solve(n,m)<<endl;
    }
}
```

f[i, j]表示用j个鸡蛋测量i次能测量的区间长度的最大值
枚举扔鸡蛋的楼层k，类似dp1，没碎测k楼以上，碎了测k楼以下，那么能测的最大高度就是上下两部分加上第k层楼这一层

```c++
#include <iostream>
using namespace std;

int f[110][15], n, m;

int main() {
    while (cin >> n >> m) {
        for (int i = 1; i <= n; i ++ ) {
            for (int j = 1; j <= m; j ++ )
                f[i][j] = f[i - 1][j] + f[i - 1][j - 1] + 1;
            if (f[i][m] >= n) {
                cout << i << endl;
                break;
            }
        }
    }
    return 0;
}
```

####  最近公共祖先

在一个没有公共元素的二叉树中寻找特定元素

```c++
// 定义：在以 root 为根的二叉树中寻找值为 val 的节点
/*
struct TreeNode{
	int val,left,right;
};
*/
TreeNode find(TreeNode root, int val) {
    // base case
    if (root == null) {
        return null;
    }
    // 看看 root.val 是不是要找的
    if (root.val == val) {
        return root;
    }
    // root 不是目标节点，那就去左子树找
    TreeNode left = find(root.left, val);
    if (left != null) {
        return left;
    }
    // 左子树找不着，那就去右子树找
    TreeNode right = find(root.right, val);
    if (right != null) {
        return right;
    }
    // 实在找不到了
    return null;
}
```

**如果一个节点能够在它的左右子树中分别找到`p`和`q`，则该节点为`LCA`节点**。

```c++
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    return find(root, p.val, q.val);
}

// 在二叉树中寻找 val1 和 val2 的最近公共祖先节点
TreeNode find(TreeNode root, int val1, int val2) {
    if (root == null) {
        return null;
    }
    // 前序位置
    if (root.val == val1 || root.val == val2) {//c
        // 如果遇到目标值，直接返回
        return root;
    }
    TreeNode left = find(root.left, val1, val2);
    TreeNode right = find(root.right, val1, val2);
    // 后序位置，已经知道左右子树是否存在目标值 左右子树都存在值 才是祖先
    if (left != null && right != null) {
        // 当前节点是 LCA 节点
        return root;
    }

    return left != null ? left : right;
}
```

