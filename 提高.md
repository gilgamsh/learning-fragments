### DP

#### 数字三角形模型

##### 摘花生

网格 左上到右下 不走回头路 求最大值

1. dp 阶段、决策 最优子结构 无后效性

2. 从集合角度来考虑dp问题 
   1. 状态表示 f[i,j] 
      1. 集合 所有从(1,1)走到(i,j)的路线（以左上为原点  x向下 y向右 和打印顺序一样）
      2. 属性 Max/Min/数量
      
   2. 状态计算 常用的**划分依据**  “最后一步”  **划分原则** 不漏 不重复
   
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 110;
int a[N][N];
LL f[N][N];
void solve(){
    int r,c; cin >> r>>c;
    memset(a,0,sizeof a);
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            cin >> a[i][j];
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j]; //
    cout << f[r][c]<<endl;
}
int main()
{
    int t;cin >> t;
    for (int i = 1; i <= t; i ++ )solve();
} 
```

##### 最低通行费

网格  左上到右下 不走回头路 求最小值

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int a[N][N];
int f[N][N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            cin >> a[i][j];
    for (int i = 1; i <= n; i ++ )f[i][1]=f[i-1][1]+a[i][1];
    for (int i = 1; i <= n; i ++ )f[1][i]=f[1][i-1]+a[1][i];
    for (int i=2;i<=n;i++)
        for (int j = 2; j <= n; j ++ )
            f[i][j]=min(f[i-1][j],f[i][j-1])+a[i][j];
    cout << f[n][n];
}
```

##### 方格取数      

方格 左上到右下 不走回头路  走两次 两次相关 同时枚举 最后一步的情况是四种 当两条路径重合的时候 

**格子值只会被计算一次** 可以重合 但是值只算一次 所以计算f数组的值的时候 需要考虑两条路径是不是有重合 **而只有两个路线的步数一致时 才有可能重合。所以用K表示步数**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 20;
int a[N][N];
int f[2*20][N][N];
int main()
{
    int n;cin>>n;
    int r=1,c,num;
    while(r!=0){
        cin >> r>>c>>num;
        if(r==0)break;
        a[r][c]=num;
    }
    f[2][1][1]=a[1][1];
    for(int k=3;k<=2*n;k++){
        for(int i=1;i<k&&i<=n;i++){
            for(int j=1;j<k&&j<=n;j++){
                int t =a[i][k-i];
                if(i!=j) t+=a[j][k-j];
                int & tmp=f[k][i][j];
                tmp=max(tmp,f[k-1][i-1][j]+t);
                tmp=max(tmp,f[k-1][i-1][j-1]+t);
                tmp=max(tmp,f[k-1][i][j-1]+t);
                tmp=max(tmp,f[k-1][i][j]+t);
            }
        }
    }
    cout << f[2*n][n][n];
}
```

##### 传纸条

网格 左上到右下 两条 不能重复 求路径上的最大值

状态表示是有意义的 **可以推出答案** **每个状态可被计算**  和方格取数本质上一样 方格取数中 两条路径也不会有交点

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 55;
int a[N][N];
int f[2*N][N][N];
int main()
{
    int m,n;cin>>m>>n;
    for (int i = 1; i <= m; i ++ ){
        for (int j = 1; j <= n; j ++ ){
            cin >> a[i][j];
        }
    }
    f[2][1][1]=a[1][1];
    for(int k=3;k<=m+n;k++){
        for(int i=1;i<k&&i<=m;i++){
            for(int j=1;j<k&&j<=m;j++){
                if(k!=m+n && i==j)continue;
                int t =a[i][k-i];
                t+=a[j][k-j];
                int &tmp=f[k][i][j];
                tmp=max(tmp,f[k-1][i-1][j]+t);
                tmp=max(tmp,f[k-1][i-1][j-1]+t);
                tmp=max(tmp,f[k-1][i][j-1]+t);
                tmp=max(tmp,f[k-1][i][j]+t);
            }
        }
    }
    //cout<<f[5][2][3]<<endl;
    
    cout << f[m+n-1][m][m-1];
}
```

#### 最长上升子序列模型

##### 怪盗基德的滑翔翼

注意可以从两端算起 $$O(n^2)$$做法

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 110;
int a[N];
int f[N];
void solve(){
    memset(a, 0, sizeof a);
    memset(f, 0, sizeof f);
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }
    for (int i = 1; i <= n; i ++ )f[i]=1;
    for (int i = 1; i <= n; i ++ ){
        for (int j = 1; j < i; j ++ ){
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    memset(f, 0, sizeof f);
    for (int i = n; i >= 1; i -- )f[i]=1;
    for (int i = n; i >= 1; i -- ){
        for (int j = n; j > i; j -- ){
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout<<res<<endl;
}

int main()
{
    int k;cin>>k;
    for (int i = 1; i <= k; i ++ )solve();
}
```

##### 登山

先求最长上升 再求最长下降 然后两个状态重叠

1. 编号递增 子序列
2. 一旦开始下降就不难上升 先上升再下降

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N],f[N],g[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin >> a[i],f[i]=g[i]=1;
    for (int i = 1; i <= n; i ++ ){
        for (int j = 1; j < i; j ++ ){
            if(a[j]<a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for (int i = n; i >= 1; i -- ){
        for (int j = n; j > i; j -- ){
            if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]+g[i]-1);
    cout << res <<endl;
}
```

##### 合唱队形

序列 求最长上升和最长下降 然后取一个总和的状态 上面的对偶问题

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int a[N];
int f[N],g[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin >>a[i];
    for(int i=1;i<=n;i++){
        f[i]=1;
        for (int j = 1; j < i; j ++ ){
            if(a[j]<a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for(int i=n;i>=1;i--){
        g[i]=1;
        for (int j = n; j > i; j -- ){
            if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]+g[i]-1);
    cout << n-res;
}
```

##### 友好城市

要保证没有交集，那么就需要保证上下两个序列均为上升的 排序了下面的序列，那么就已经能保证下方的序列为上升的，在这个的前提下就可以将这个题目转换为求最长上升子序列

```c++
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
const int N = 5010;
typedef pair<int,int> PII;
PII a[N];
int b[N],f[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ ){
        int x,y;cin>>x>>y;
        a[i]={x,y};
    }
    sort(a+1,a+n+1);
    for (int i = 1; i <= n; i ++ )b[i]=a[i].y;
    for (int i = 1; i <= n; i ++ ){
        f[i]=1;
        for (int j = 1; j < i; j ++ )
            if(b[j]<=b[i])f[i]=max(f[i],f[j]+1);
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout << res;
}
```

##### 最大上升子序列和

维护的属性变成最大上升子序列的和的最大值

```c++
#include <bits/stdc++.h>
using namespace std;
const int N=1010;
int a[N],f[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin>>a[i];
    for (int i = 1; i <= n; i ++ ){
        f[i]=a[i];
        for (int j = 1; j < i; j ++ )
            if(a[j]<a[i])f[i]=max(f[i],f[j]+a[i]);
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout << res;
}
```

##### 拦截导弹

Dilworth定理：偏序集的最少反链划分数等于最长链的长度，说简单点其实就是第二问相当于求最长上升子序列

具体动机 如下

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323204343366.png" alt="image-20220323204343366" style="zoom: 80%;" />

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323204412485.png" alt="image-20220323204412485" style="zoom:80%;" />

调整的方法在于 将第一个不同的数交换 可以将贪心法找到的解调整为最优解 并且每次调整没有增加解的个数

贪心的过程类似于

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N],idx,f[N],g[N];
int main()
{
    int tmp;
    while(scanf("%d",&tmp)==1){
        a[++idx]=tmp;
    }
    for (int i = 1; i <= idx; i ++ ){
        f[i]=1;
        for (int j = 1; j < i; j ++ )
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
    }
    for (int i = 1; i <= idx; i ++ ){
        g[i]=1;
        for (int j = 1; j < i; j ++ )
        if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
    }
    int res1=0,res2=0;
    for (int i = 1; i <= idx; i ++ )res1=max(res1,f[i]);
    for (int i = 1; i <= idx; i ++ )res2=max(res2,g[i]);
    cout << res1<<endl;
    cout << res2;
}
```

##### 导弹防御体系

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323214812369.png" alt="image-20220323214812369" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 55;
int n,a[N],up[N],down[N];
bool dfs(int depth,int id,int u,int d)//u是上升子序列的数目 d是下降子序列的数目  i是当前需要处理的数字的序号
{
    if(u+d>depth)return false;
    if(n+1==id)return true;//当要处理的下标越界时 处理完毕了
    
    //枚举放入最长上升子序列的情况  up数组单减 
    bool flag=false;
    for(int i=1;i<=u;i++){
        if(up[i]<a[id]){
            int t=up[i];//u[i]旧值 用于回溯
            up[i]=a[id];
            if(dfs(depth,id+1,u,d))return true;
            flag=true;
            up[i]=t;
            break;
        }
    }
    if(!flag){
        up[u+1]=a[id];
        if(dfs(depth,id+1,u+1,d))return true;
    }
    
    flag=false;
    for(int i=1;i<=d;i++){//down 数组单增
        if(down[i]>a[id]){
            int t=down[i];
            down[i]=a[id];
            if(dfs(depth,id+1,u,d))return true;
            flag=true;
            down[i]=t;
            break;
        }
    }
    if(!flag){
        down[d+1]=a[id];
        if(dfs(depth,id+1,u,d+1))return true;
    }
    return false;
}

void solve(){
    int depth=0;
    while(!dfs(depth,1,0,0))depth++;
    cout << depth<<endl;
}

int main()
{
    cin>>n;
    while(n!=0){
        memset(a,0,sizeof a);
        for (int i = 1; i <= n; i ++ )cin>>a[i];
        solve();
        cin >> n;
    }
}
```

##### 最长上升公共子序列

不能先求公共子序列 再求上升自序列 

反例 

5

5 3 2 1 4    最长的公共自序列是 5 4 或者 3 4等等

3 5 4 2 1 

注意此例

10
1 5 3 6 3 2 7 3 6 2 
9 6 2 3 1 5 3 3 6 1  考虑f[1] [5]

![image-20220324205252518](C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220324205252518.png)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3010;
int n, a[N], b[N], f[N][N];
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> a[i];
  for (int i = 1; i <= n; i++) cin >> b[i];
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      int &x = f[i][j];
      x = f[i - 1][j];
      if (a[i] == b[j]){
        x=1;
        for (int k = 1; k < j; k++) {
          if (b[k] < b[j]) x = max(x, f[i - 1][k] + 1);
        }
        }
    }
  }
  int res = 0;
  for(int i=1;i<=n;i++){
      for (int j = 1; j <= n; j ++ ){
          cout << f[i][j]<<" ";
      }
      puts("");
  }
  cout << res;
}
```

然后我们发现每次循环求得的maxv是满足a[i] > b[k]的f[i - 1] [k] + 1的前缀最大值。
因此可以直接将maxv提到第一层循环外面，减少重复计算，此时只剩下两重循环。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3010;
int n, a[N], b[N], f[N][N];
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> a[i];
  for (int i = 1; i <= n; i++) cin >> b[i];
  
  for (int i = 1; i <= n; i++) {
    int maxv=0;//记录 f[i-1][j]的前j个数的最大值
    for (int j = 1; j <= n; j++) {//此时maxv的值是f[i-1][j-1]的前缀最大值
      int &x = f[i][j];
      x = f[i - 1][j];
      if (a[i] == b[j]){
        x=max(x,maxv+1);    //第j个在
      }
      if(a[i]>b[j])maxv=max(maxv,f[i-1][j]);//更新f[i-1][j]的前缀最大值
    }
  }
  int res = 0;
  for(int i=1;i<=n;i++){
      for (int j = 1; j <= n; j ++ ){
          res=max(res,f[i][j]);
      }
  }
  cout << res;
}
```

#### 背包

##### 采药

如果 不能放下第j个 也要记得更新

```c++
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 110,M=1010;
PII a[N];
int t,m;
int f[N][M];
int main()
{
    cin >> t>>m;
    for (int i = 1; i <= m; i ++ )cin>>a[i].x>>a[i].y;
    for (int i = 1; i <= m; i ++ ){
        int tt=a[i].x,nn=a[i].y;
        for(int j=1;j<=t;j++){
            f[i][j]=f[i-1][j];
            if(j>=tt)f[i][j]=max(f[i-1][j],f[i-1][j-tt]+nn);
        }
    }
    cout << f[m][t];
}
```

##### 装箱问题

题目里面 价值 和 体积是值一样

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 40,V=20010;
int v,n;
int a[N],f[N][V];
int main()
{
    cin >> v>>n;
    for (int i = 1; i <= n; i ++ ) cin>>a[i];
    for (int i = 1; i <= n; i ++ ) f[i][0]=1,f[i][a[i]]=1;
    
    for (int i = 1; i <= n; i ++ ){
        for (int j = 0; j <= v; j ++ ){
            if(f[i-1][j])f[i][j]=1;
            if(f[i-1][j]&&j+a[i]<=v)f[i][j+a[i]]=1;
        }
    }
    int res=0;
    for (int j = 0; j <= v; j ++ )if(f[n][j])res=j;
    cout << v-res;
}
```

##### 宠物小精灵之收服

在背包问题中，体积w与价值v是可以互逆的！
可以将f[i]表示为体积为i能装的最大价值，也可以将f[i]表示为价值为i所需的最小体积。
两者等价，我们只需要选择范围较小的那维作为体积就可以了！ 这直接影响到时空复杂度。

朴素的二维的dp

```c++
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 1010, M = 510, K = 110;
PII a[K];
int n, m, k, f[2][M][N];
int main() {
  cin >> n >> m >> k;
  for (int i = 1; i <= k; i++) {
    cin >> a[i].x >> a[i].y;
  }
  for (int i = 1; i <= k; i++) {      //枚举k个小精灵
    for (int j = 0; j < m; j++) {     // j是体力值
      for (int w = 0; w <= n; w++) {  // w是精灵球的数量
        int ww = a[i].x, jj = a[i].y;
        int &x = f[i % 2][j][w];
        x = f[(i - 1) % 2][j][w];
        if (w >= ww && j >= jj) x = max(x, f[(i - 1) % 2][j - jj][w - ww] + 1);
      }
    }
  }
  int c = 0, r = m;
  for (int i = 0; i < m; i++) {
    for (int j = 0; j <= n; j++) {
      if (f[k % 2][i][j] > c) {
        c = f[k % 2][i][j];
        r = m - i;
      }
      if (f[k % 2][i][j] == c) {
        r = max(r, m - i);
      }
    }
  }
  cout << c << " " << r;
  return 0;
}
```

优化做法  太痛苦了 忘记初始化了 如果

```c++
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 1010, M = 510, K = 110, INF = 0x3f3f3f3f;
PII a[K];
int n, m, k, f[2][M][K];
int main() {
  memset(f, 0x3f, sizeof f);
  cin >> n >> m >> k;
  for (int i = 1; i <= k; i++) {
    cin >> a[i].x >> a[i].y;
  }
  memset(f, 0x3f, sizeof f);
  f[0][0][0] = 0;                     //不抓小精灵肯定不用精灵球
  f[1][0][0] = 0;                     //不抓小精灵不用精灵球
  for (int i = 1; i <= k; i++) {      //枚举考虑第i个小精灵
    for (int j = 0; j < m; j++) {     //花费了m体力
      for (int w = 0; w <= i; w++) {  //抓了i个小精灵
        int &t = f[(i) % 2][j][w];
        t = f[(i - 1) % 2][j][w];  //最少多少精灵球
        int nn = a[i].x, tt = a[i].y;
        if (j >= tt && w >= 1 && f[(i - 1) % 2][j - tt][w - 1] + nn <= n)
          t = min(t, f[(i - 1) % 2][j - tt][w - 1] + nn);
      }
    }
  }
  int c = 0, r = m;
  for (int i = 0; i < m; i++) {
    for (int j = 1; j <= k; j++) {
      if (f[(k) % 2][i][j] <= n) {
        if (c < j)
          r = m - i, c = j;
        else if (c == j)
          r = max(r, m - i);
      }
    }
  }

  cout << c << " " << r;
  return 0;
}
```

##### 数字组合

M看成是背包容量 每个数是一个物品 Ai是体积 总体积恰好是M的方案数

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220325153819418.png" alt="image-20220325153819418" style="zoom:80%;" />

```c++
//已知 有n个数 目标是和为n  求最大方案数
#include <bits/stdc++.h>
using namespace std;
const int N = 110, M = 10010;
int n, m, a[N], f[N][M];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) cin >> a[i];

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      int &x = f[i][j];
      x = f[i - 1][j];  //不用第i个数
      if (j > a[i])
        x += f[i - 1][j - a[i]];  //用第i个数
      else if(j==a[i])
        x += 1;
    }
  }
  cout << f[n][m];

  return 0;
}
```

##### 买书

完全背包问题 变成了方案数  需要把n元全部花完

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220325155312279.png" alt="image-20220325155312279" style="zoom:80%;" />

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[5]={0,10,20,50,100},n;
int f[2][N];
int main()
{
    cin >> n;
    f[0][0]=f[1][0]=1;
    for (int i = 1; i <= 4; i ++ ){
        for (int j = 0; j <= n; j ++ ){
            int &x=f[i%2][j];
            x=f[(i-1)%2][j];//不买第i本书
            if(j>a[i])x+=f[(i)%2][j-a[i]];
            else if(j==a[i])x+=1;
        }
    }
    cout<<f[4%2][n];
}
```

##### 货币系统

卡int了 n个物品 容量为m的背包 完全背包

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 20,M=3010;
LL n,m,a[N],f[2][M];
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ){//
        cin >> a[i];
    }
    f[0][0]=f[1][0]=1;
    for (int i = 1; i <= n; i ++ ){
        for (int j = 1; j <= m; j ++ ){
            LL &x=f[i%2][j];
            x=f[(i-1)%2][j];//不用第i个货币 组成j的方案
            if(j>=a[i])x+=f[(i)%2][j-a[i]];// 
        }
    }
    cout << f[n%2][m];
}
```

##### 货币系统（中等）

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220325232353785.png" alt="image-20220325232353785" style="zoom:80%;" />

将a1 a2 an从小到大排序 因为这里的系数非负 所以只能小数来表示大数

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110, M = 25010;
int a[N], f[2][M];
void solve() {
  memset(a, 0, sizeof a);
  memset(f, 0, sizeof f);
  int n;
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> a[i];
  sort(a + 1, a + n + 1);
  int m = a[n], res = 0;
  f[0][0] = f[1][0] = 1;
  for (int i = 1; i <= n; i++) {
    if (!f[(i - 1) % 2][a[i]]) res++;//如果前i个数不能表示 a[i]
    for (int j = 1; j <= m; j++) {
      int &x = f[i % 2][j];
      x = f[(i - 1) % 2][j];
      if (j >= a[i]) x |= f[i % 2][j - a[i]];
    }
  }
  cout << res << endl;
}
int main() {
  int t;
  cin >> t;
  for (int i = 1; i <= t; i++) {
    solve();
  }
  return 0;
}
```

##### 多重背包问题（单调队列优化）

传统推导

```c++
dp[i][j] 表示将前 i 种物品放入容量为 j 的背包中所得到的最大价值
dp[i][j] = max(不放入物品 i，放入1个物品 i，放入2个物品 i, ... , 放入k个物品 i)
这里 k 要满足：k <= s, j - k*v >= 0

不放物品  i = dp[i-1][j]
放k个物品 i = dp[i-1][j - k*v] + k*w

dp[i][j] = max(dp[i-1][j], dp[i-1][j-v] + w, dp[i-1][j-2*v] + 2*w,..., dp[i-1][j-k*v] + k*w)
```

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220326103237845.png" alt="image-20220326103237845" style="zoom:80%;" />

r是j 模v的余数

```c++
#pragma GCC optimize(3)
#pragma GCC optimize("inline")
#include <bits/stdc++.h>
using namespace std;
const int N = 20010;
int n, m;
int f[2][N];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    int v, w, s;
    cin >> v >> w >> s;          //每件体积是v 价值是w 数量是s
    for (int r = 0; r < v; r++)  // 体积除以v的余数
    {
      deque<int> Q;
      for (int k = r; k <= m; k += v)  //模v的 r的同余类
      {
        if (!Q.empty() && (k - Q.front()) / v > s) Q.pop_front(); // 是否超过了s个
        while (!Q.empty() &&
               f[(i - 1) % 2][Q.back()] - (Q.back() - r) / v * w <=
                   f[(i - 1) % 2][k] - (k - r) / v * w)
          Q.pop_back();
        Q.push_back(k);
        f[i % 2][k] = f[(i - 1) % 2][Q.front()] + (k - Q.front()) / v * w;
      }
    }
  }

  cout << f[n % 2][m] << endl;

  return 0;
}
```

##### 庆功会

多重背包

```c++
#include<bits/stdc++.h>
using namespace std;
const int M = 6010;
int n,m,f[2][M];
int main()
{
    cin >> n >>m;
    for (int i = 1; i <= n; i ++ ){
        int v,w,s;
        cin >> v>> w>> s;
        for (int r = 0; r < v; r ++ ){
            deque<int> Q;
            for (int j = r; j <= m; j +=v ){
                while(!Q.empty() && (j-Q.front())/v >s )Q.pop_front();
                while(!Q.empty() && f[(i-1)%2][Q.back()]-(Q.back()-r)/v*w <= 
                                    f[(i-1)%2][j]-(j-r)/v*w)Q.pop_back();
                Q.push_back(j);
                f[i%2][j]=f[(i-1)%2][Q.front()] + (j-Q.front())/v*w;
            }
        }
    }
    cout << f[n%2][m];
}
```

##### 混合背包问题

有三类物品 第一类只能用1次 第二类可以无限次，第三类可以si次

```c++
#include <bits/stdc++.h>
using namespace std;
const int V = 1010, INF = 0x3f3f3f3f;
int n, vv, f[2][V];
int main() {
  cin >> n >> vv;
  for (int i = 1; i <= n; i++) {
    int v, w, s;
    cin >> v >> w >> s;
    if (s == -1 || s == 0) {
      for (int j = 0; j <= vv; j++) {
        int &x = f[i % 2][j];
        x = f[(i - 1) % 2][j];
        if (s == -1) {
          if (j >= v) x = max(x, f[(i - 1) % 2][j - v] + w);
        }
        if (s == 0) {
          if (j >= v) x = max(x, f[(i) % 2][j - v] + w);
        }
      }
    } else {
      for (int r = 0; r < v; r++) {
        deque<int> Q;
        for (int j = r; j <= vv; j += v) {
          int &x = f[i % 2][j];
          x = f[(i - 1) % 2][j];
          while (!Q.empty() && (j - Q.front()) / v > s) Q.pop_front();
          while (!Q.empty() &&
                 f[(i - 1) % 2][Q.back()] - (Q.back() - r) / v * w <=
                     f[(i - 1) % 2][j] - (j - r) / v * w)
            Q.pop_back();
          Q.push_back(j);
          x = max(x, f[(i - 1) % 2][Q.front()] + (j - Q.front()) / v * w);
        }
      }
    }
  }

  cout << f[n % 2][vv];

  return 0;
}
```

##### 二维费用的背包问题

限制不只有体积 还有重量 也就是限制变成了二维的 

```c++
#include <bits/stdc++.h>
using namespace std;
const int V = 110, M = 110;
int n, v, m, f[2][V][M];
int main() {
  cin >> n >> v >> m;
  for (int i = 1; i <= n; ++i) {
    int vi, mi, wi;
    cin >> vi >> mi >> wi;
    for (int j = 0; j <= v; j++) {
      for (int k = 0; k <= m; k++) {
        int &x = f[i & 1][j][k];
        x = f[(i - 1) % 2][j][k];
        if (j >= vi && k >= mi) x = max(x, f[(i - 1) % 2][j - vi][k - mi] + wi);
      }
    }
  }
  cout << f[n % 2][v][m];
  return 0;
}
```

##### 潜水员

至多，恰好，至少 这三种状态转移方程都是一样的，
不同的是状态的定义域不同（前两者在负数上没有定义，后者有）和初始边界的不同了。

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220326212543063.png" alt="image-20220326212543063" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
using namespace std;
const int M = 26, N = 89;
int m, n, k, f[2][M][N];
int main() {
  memset(f, 0x3f, sizeof f);
  cin >> m >> n >> k;
  f[0][0][0] = f[1][0][0] = 0;
  for (int i = 1; i <= k; i++) {
    int a, b, c;
    cin >> a >> b >> c;
    for (int j = 0; j <= m; j++) {    //氧气
      for (int w = 0; w <= n; w++) {  //氮气
        int &x = f[(i) % 2][j][w];
        x = f[(i - 1) % 2][j][w];
        x = min(x, f[(i - 1) % 2][max(0, j - a)][max(0, w - b)] + c);
      }
    }
  }
  cout << f[k % 2][m][n] << endl;
  return 0;
}
```



##### 机器分配

转化为分组背包问题 循环从外到内 是 分组数 体积大小 数目

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 15, M = 25;
int n, m, f[N][M], ww[N][M];
int way[N];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      int w;
      cin >> w;
      ww[i][j] = w;
      for (int k = 0; k <= m; k++) {
        int &x = f[i][k];
        x = max(x, f[(i - 1)][k]);
        if (k >= j) x = max(x, f[(i - 1)][k - j] + w);
      }
    }
  }

  cout << f[n][m] << endl;
  int left = m;  //剩余的机器数
  for (int i = n; i >= 1; i--) {
    for (int j = 0; j <= left; j++) {
      if (f[i][left] == f[i - 1][left - j] + ww[i][j]) {
        way[i] = j;
        left -= j;
        break;
      }
    }
  }
  for (int i = 1; i <= n; i++) cout << i << " " << way[i] << endl;
  return 0;
}
```

##### 开心的金明

01背包

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3e4 + 5;
int n, m, f[2][N];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= m; i++) {
    int v, p;
    cin >> v >> p;
    int w = v * p;
    for (int j = 0; j <= n; j++) {
      int &x = f[i % 2][j];
      x = f[(i - 1) % 2][j];
      if (j >= v) x = max(x, f[(i - 1) % 2][j - v] + w);
    }
  }
  cout << f[m % 2][n];
  return 0;
}
```

##### 有依赖的背包问题

转化为分组背包问题 一组是一颗子树 每一件物品是改子树的每一个体积的值

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
struct Edge {
  int to;
  Edge(int _to) { to = _to; }
};
vector<Edge> edges[N];
struct Thing {
  int v, w;
};
Thing things[N];
int n, v, f[N][N];

void dfs(int u) {
  int vv = things[u].v, ww = things[u].w;
  for (auto t : edges[u]) {//分组背包先 循环组数 再循环体积 再循环每组中的物品
    dfs(t.to);
    for (int j = v; j >= 0; j--) {//体积要从小到大
      for (int k = 0; k <= j; k++) {
        if (j >= k) f[u][j] = max(f[u][j], f[u][j - k] + f[t.to][k]);
      }
    }
  }//先考虑只选择子树
  for (int i = v; i >= vv; i--) f[u][i] = f[u][i - vv] + ww;//一定要选根
  for (int i = 0; i < vv; i++) f[u][i] = 0;
}

int main() {
  cin >> n >> v;
  int root;
  for (int i = 1; i <= n; i++) {
    int p;
    cin >> things[i].v >> things[i].w >> p;
    if (p == -1)
      root = i;
    else
      edges[p].emplace_back(i);
  }
  dfs(root);
  cout << f[root][v];
  return 0;
}
```

##### 背包问题求方案数



```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, mod = 1000000007;

int n, m;
int f[N], g[N];
int v[N], w[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

    for (int i = 0; i <= m; i ++ ) g[i] = 1;

    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= v[i]; j -- )
        {
            int left = f[j], right = f[j - v[i]] + w[i];
            f[j] = max(left, right);

            if (left > right) g[j] = g[j];
            else if (left < right) g[j] = g[j - v[i]];
            else g[j] = g[j] + g[j - v[i]];
            g[j] %= mod;
        }

    cout << g[m] << endl;
    return 0;
}
```

##### 背包问题求具体方案

本质上讲 dp可以变成最短路问题 从终点 反推到起点  由于倒退只能从后往前的字典序最小 所以把物品的顺序反一下 求dp

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int n, m, f[N][N], way[N], v[N], w[N];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) cin >> v[n - i + 1] >> w[n - i + 1];
  for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= m; j++) {
      int &x = f[i][j];
      x = f[(i - 1)][j];
      if (j >= v[i]) x = max(x, f[(i - 1)][j - v[i]] + w[i]);
    }
  }
  int j = m, idx = 0;
  for (int i = n; i >= 1; i--) {
    if (j >= v[i] && f[i][j] == f[i - 1][j - v[i]] + w[i]) {
      way[++idx] = i;
      j -= v[i];
      continue;
    }
    if (f[i][j] == f[i - 1][j]) {
      continue;
    }
  }
  for (int i = 1; i <= idx; i++) {
    cout << n - way[i] + 1 << " ";
  }

  return 0;
}
```

##### 能量石

贪心+DP 首先如果直接DP 需要枚举 吃的石头的方案和吃的顺序。 通过贪心 可以将吃的顺序固定。证明类似于国王游戏和叠罗汉

之后使用DP 类似于0x背包

贪心的证明

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220328173304603.png" alt="image-20220328173304603" style="zoom:80%;" />

01背包过程

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220328173221751.png" alt="image-20220328173221751" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110, T = 10010, INF = 0x3f3f3f3f;
struct Stone {
  int s, e, l;
  bool operator<(const Stone& x) const { return s * x.l < l * x.s; }
};
Stone a[N];
int f[2][T];
void solve(int k) {
  memset(a, 0, sizeof a);
  memset(f, 0, sizeof f);
  int n, t = 0;
  cin >> n;
  for (int i = 1; i <= n; i++) {
    int s, e, l;
    cin >> s >> e >> l;
    a[i] = {s, e, l};
    t += s;
  }
  sort(a + 1, a + n + 1);  //确定了吃的顺序

  for (int i = 1; i <= n; i++) {
    int s, e, l;
    s = a[i].s, e = a[i].e, l = a[i].l;
    for (int j = 0; j <= t; j++) {
      int& x = f[i % 2][j];
      x = f[(i - 1) % 2][j];
      if (j >= s) x = max(x, f[(i - 1) % 2][j - s] + max(0, (e - l * (j - s))));
    }
  }
  int res = 0;
  for (int i = 1; i <= t; i++) res = max(res, f[n % 2][i]);
  cout << "Case #" << k << ":"
       << " " << res << endl;
}

int main() {
  int t;
  cin >> t;
  for (int i = 1; i <= t; i++) {
    solve(i);
  }

  return 0;
}
```

##### 金明的预算方案

分组背包问题 由于每组的可选数比较少 所以这么做

```c++
#include <bits/stdc++.h>
#define eb emplace_back
using namespace std;
const int N = 65, M = 32010;
int n, m, idx;
struct Thing {
  int w, v;  // w表示价格*重要度 v表示价格
  Thing(int _w, int _v) { w = _w, v = _v; }
};
vector<Thing> a[N];
int f[M];
int main() {
  cin >> m >> n;
  for (int i = 1; i <= n; i++) {
    int v, p, q;
    cin >> v >> p >> q;
    if (q == 0)
      a[i].eb(v * p, v);
    else
      a[q].eb(v * p, v);
  }
  for (int i = 1; i <= n; i++) {
    if (a[i].empty()) continue;
    for (int j = m; j >= 0; j--) {
      int &x = f[j];
      for (int k = 0; k < 1 << (a[i].size() - 1); k++) {
        int w = a[i][0].w, v = a[i][0].v;//每次枚举选项之前 重新计算w 于v
        for (int t = 0; t < a[i].size() - 1; t++) {
          if (k >> t & 1) {
            w += a[i][t + 1].w;
            v += a[i][t + 1].v;
          }
        }
        if (i == 1 && j == m) cerr << w << " " << v << endl;
        if (j >= v) x = max(x, f[j - v] + w);
      }
    }
  }
  cout << f[m];

  return 0;
}
```

#### 状态机模型

##### 大盗阿福

分为最后一个选了 和 最后一个没选 两个状态

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int a[N];
int f[N][2];
void solve() {
  int n;
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  for (int i = 1; i <= n; i++) {
    f[i][0] = max(f[i - 1][0], f[i - 1][1]);
    f[i][1] = f[i - 1][0] + a[i];
  }
  cout << max(f[n][0], f[n][1]) << endl;
}

int main() {
  ios::sync_with_stdio(0);
  int t;
  cin >> t;
  for (int i = 1; i <= t; i++) {
    solve();
  }

  return 0;
}
```

##### 股票买卖 IV

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10, K = 110;
int n, k;
int a[N], f[N][K][2];
int main() {
  cin >> n >> k;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  memset(f, -0x3f, sizeof f);
  for (int i = 0; i <= n; i++) f[i][0][0] = 0;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= k; j++) {
      f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + a[i]);
      f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - a[i]);
    }
  }
  int res = 0;
  for (int i = 0; i <= k; i++) res = max(res, f[n][i][0]);
  cout << res;

  return 0;
}
```

##### 股票买卖V

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010, INF = 0x3f3f3f3f;

int n;
int w[N];
int f[N][3];

int main()
{
    scanf("%d", &n);

    for (int i = 1; i <= n; i ++ ) scanf("%d", &w[i]);

    f[0][0] = f[0][1] = -INF, f[0][2] = 0;
    for (int i = 1; i <= n; i ++ )
    {
        f[i][0] = max(f[i - 1][0], f[i - 1][2] - w[i]);
        f[i][1] = f[i - 1][0] + w[i];
        f[i][2] = max(f[i - 1][2], f[i - 1][1]);
    }

    printf("%d\n", max(f[n][1], f[n][2]));

    return 0;
}
```

##### 设计密码（难）

状态表示为f[i,j] 第i个字母 当前与模式串匹配到j这个状态 匹配使用kmp TODO:

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 55,MOD=1e9+7;
int n;string str;
int pmt[N],f[N][N];
int main()
{
    cin >> n >> str;
    for(int i=1,j=0;i<str.size();i++){
        while(j&&str[i]!=str[j])j=pmt[j-1];
        if(str[i]==str[j])j++;//j是还没有匹配的下标
        pmt[i]=j;
    }
    f[0][0]=1;
    int m=str.size();
    for (int i = 0; i <=n; i ++ ){
        for (int j = 0; j < m; j ++ ){//枚举匹配到的每个状态 j表示当前还没有匹配的地方
            for(char k='a';k<='z';k++){//第i个数的26种选择
                int u=j;
                while(u && k!=str[u])u=pmt[u-1];//u是待匹配的下标
                if(k==str[u])u++;//对应于k的 状态是u
                if(u<m)f[i+1][u]=(f[i+1][u]+f[i][j])%MOD;
            }
        }
    }
    int res=0;
    for(int i=0;i<m;i++)res=(res+f[n][i])%MOD;
    cout<<res;
}
```

##### 修复DNA（超难）

f[i, j] 前i个字母 当前走到了ac自动机中的第j个节点 所有方案中 最少修改的字母数量 TODO:

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 55, S = 25;
int tr[N * S][4], idx, ne[N * S];
bool dead[N * S];  //表示每个位置会不会死
queue<int> q;
string str;
char s[N * S];
int f[1010][N * S];
int get(char c) {
  if (c == 'A') return 0;
  if (c == 'T') return 1;
  if (c == 'G') return 2;
  return 3;
}
void insert(string &str) {
  int p = 0;
  for (auto i : str) {
    int u = get(i);
    if (!tr[p][u]) tr[p][u] = ++idx;
    p = tr[p][u];
  }
  dead[p] = true;
}

void build() {
  for (int i = 0; i < 4; i++) {
    if (tr[0][i]) q.push(tr[0][i]);
  }
  while (!q.empty()) {
    int t = q.front();
    q.pop();
    for (int i = 0; i < 4; i++) {
      int p = tr[t][i];
      if (!p)
        tr[t][i] = tr[ne[t]][i];
      else {
        ne[p] = tr[ne[t]][i];
        q.push(p);
        dead[p] |= dead[ne[p]];
      }
    }
  }
}

int main() {
  int n, cnt = 0;
  while (cin >> n && n != 0) {
    memset(f, 0x3f, sizeof f);
    memset(tr, 0, sizeof tr);
    memset(ne, 0, sizeof ne);
    memset(dead, 0, sizeof dead);
    idx = 0;
    for (int i = 1; i <= n; i++) {
      cin >> str;
      insert(str);
    }
    build();
    cin >> s + 1;
    int m = strlen(s + 1);
    f[0][0] = 0;
    for (int i = 0; i < m; i++) {  //一共m个待修改的字符
      for (int j = 0; j <= idx; j++) { //j =0 表示什么都没有匹配的头节点
        for (int k = 0; k < 4; k++) {
          int t = get(s[i + 1]) != k;  //如果 k
          int u = tr[j][k];
          if (!dead[u]) f[i + 1][u] = min(f[i + 1][u], f[i][j] + t);
        }
      }
    }
    int res = 0x3f3f3f3f;
    for (int i = 0; i <= idx; i++) res = min(res, f[m][i]);
    if (res >= 0x3f3f3f3f) res = -1;
    cout << "Case " << ++cnt << ": " << res << endl;
  }

  return 0;
}
```

#### 状态压缩模型

##### 小国王

基于棋盘式的状态压缩dp  首先预处理一下 状态数量 

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220404125859207.png" alt="image-20220404125859207" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
#define eb emplace_back

using namespace std;
typedef long long LL;
const int N = 12, K = 10 * 10 + 10, S = 1 << N;
LL f[N][K][S];
bool st[S];
vector<int> states;
int main() {
  int n, m;
  cin >> n >> m;
  for (int i = 0; i < 1 << n; i++) {  //处理i状态是否是合法的
    int cnt = 0;
    st[i] = true;
    for (int j = 0; j < n; j++) {
      if ((i >> j & 1) == 1) {
        if (cnt) st[i] = false;
        cnt++;
      } else
        cnt = 0;
    }
  }
  for (int i = 0; i < 1 << n; i++) {
    if (st[i]) states.eb(i);
  }

  f[0][0][0] = 1;
  for (int i = 1; i <= n + 1; i++) {
    for (int j = 0; j <= m; j++)
      for (auto k1 : states) {  //枚举上一个状态
        int cnt1 = 0, tmp = k1;
        while (tmp) {
          cnt1 += tmp & 1;
          tmp >>= 1;
        }
        if (cnt1 > j) continue;
        for (auto k2 : states) {
          int cnt2 = 0, tmp = k2;
          while (tmp) {
            cnt2 += tmp & 1;
            tmp >>= 1;
          }
          if (j + cnt2 > m) continue;
          if ((k1 & k2) != 0 || !st[k1 | k2]) continue;
          f[i][j + cnt2][k2] += f[i - 1][j][k1];
        }
      }
  }

  LL res = 0;
  for (int i = 0; i < 1 << n; i++) res += f[n][m][i];
  cout << f[n + 1][m][0];

  return 0;
}
```

##### 玉米田

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 14, M = 1 << 12, mod = 1e8;

int n, m;
int w[N];
vector<int> state;
vector<int> head[M];
int f[N][M];

bool check(int state)
{
    for (int i = 0; i + 1 < m; i ++ )
        if ((state >> i & 1) && (state >> i + 1 & 1))
            return false;
    return true;
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j < m; j ++ )
        {
            int t;
            cin >> t;
            w[i] += !t * (1 << j);//w[i]表示 了第i行的不能种的情况 是1的地方不能种
        }

    for (int i = 0; i < 1 << m; i ++ )
        if (check(i))
            state.push_back(i);

    for (int i = 0; i < state.size(); i ++ )
        for (int j = 0; j < state.size(); j ++ )
        {
            int a = state[i], b = state[j];
            if (!(a & b))
                head[i].push_back(j);//预处理a->b是否可行
        }

    f[0][0] = 1;
    for (int i = 1; i <= n + 1; i ++ )
        for (int j = 0; j < state.size(); j ++ )
            if (!(state[j] & w[i]))
                for (int k : head[j])
                    f[i][j] = (f[i][j] + f[i - 1][k]) % mod;

    cout << f[n + 1][0] << endl;

    return 0;
}
```

##### 炮兵阵地

不是求方案数 相容条件变化了 十字形 射程增加 

状态压缩dp可以 先预处理出来每一行可能的状态 数组存放表示状态的数 和 下标之间的关系

```c++
#include <bits/stdc++.h>
#define x first
#define y second
#define eb emplace_back
using namespace std;
const int N = 110, M = 15, S = (1 << 10) + 10;
int n, m;
int g[N], cnt[S], f[2][S][S];  //记录最后两行
vector<int> states;
bool check(int s) {
  int cnt = 5;
  for (int i = 0; i < m; i++) {
    if (s >> i & 1) {
      if (cnt < 2) return false;
      cnt = 0;
    } else
      cnt++;
  }
  return true;
}
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    for (int j = 0; j < m; j++) {
      char c;//注意
      int t;
      cin >> c;
      if (c == 'P')
        t = 1;
      else
        t = 0;
      g[i] += (!t) << j;
    }
  }
  for (int i = 0; i < 1 << m; i++) {
    int tmp = i, ct = 0;
    while (tmp) {
      ct += tmp & 1;
      tmp >>= 1;
    }
    cnt[i] = ct;
    if (check(i)) states.eb(i);
  }

  for (int i = 1; i <= n; i++) {
    for (auto k1 : states) {
      for (auto k2 : states) {
        for (auto k3 : states) {
          int &x = f[i % 2][k2][k3];
          if ((k3 & g[i]) | (k2 & g[i - 1])) continue;
          if ((k1 & k2) | (k1 & k3) | (k2 & k3)) continue;
          x = max(x, f[(i - 1) % 2][k1][k2] + cnt[k3]);
        }
      }
    }
  }

  int res = 0;
  for (auto k1 : states) {
    for (auto k2 : states) {
      res = max(res, f[n % 2][k1][k2]);
    }
  }
  cout << res;

  return 0;
}
```

##### 愤怒的小鸟

重复覆盖模型（愤怒的小鸟）精确覆盖问题（八皇后、数独）；
Dancing Links为最优化解法。

集合类型的状态压缩dp

```c++
bool dfs(int state)//state表示当前哪些列已经被覆盖
{
任选没有覆盖的一列x 枚举所有能覆盖x的抛物线 
}
```

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220405152001900.png" alt="image-20220405152001900" style="zoom: 80%;" />

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

#define x first
#define y second

using namespace std;

typedef pair<double, double> PDD;

const int N = 18, M = 1 << 18;
const double eps = 1e-8;

int n, m;
PDD q[N];//所有的点
int path[N][N];//path[i][j]由 第i个点 和 第j个点 和零点 所确定的抛物线 能划过的点的状态
int f[M];//每个状态所需要的额外的抛物线

int cmp(double x, double y)
{
    if (fabs(x - y) < eps) return 0;
    if (x < y) return -1;
    return 1;
}

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        cin >> n >> m;
        for (int i = 0; i < n; i ++ ) cin >> q[i].x >> q[i].y;

        memset(path, 0, sizeof path);
        for (int i = 0; i < n; i ++ )
        {
            path[i][i] = 1 << i;
            for (int j = 0; j < n; j ++ )
            {
                double x1 = q[i].x, y1 = q[i].y;
                double x2 = q[j].x, y2 = q[j].y;
                if (!cmp(x1, x2)) continue;
                double a = (y1 / x1 - y2 / x2) / (x1 - x2);
                double b = y1 / x1 - a * x1;

                if (cmp(a, 0) >= 0) continue;
                int state = 0;
                for (int k = 0; k < n; k ++ )
                {
                    double x = q[k].x, y = q[k].y;
                    if (!cmp(a * x * x + b * x, y)) state += 1 << k;
                }
                path[i][j] = state;
            }
        }

        memset(f, 0x3f, sizeof f);
        f[0] = 0;
        for (int i = 0; i + 1 < 1 << n; i ++ )//枚举每一个状态
        {
            int x = 0;//x记录当前没有覆盖的第一个点
            for (int j = 0; j < n; j ++ )
                if (!(i >> j & 1))
                {
                    x = j;
                    break;
                }

            for (int j = 0; j < n; j ++ )
                f[i | path[x][j]] = min(f[i | path[x][j]], f[i] + 1);
        }

        cout << f[(1 << n) - 1] << endl;
    }

    return 0;
}
```

##### 宝藏

一个二进制数 i `for(int j=(i-1)&i;j!=0;j=(j-1)&i);` TODO:

#### 区间模型

#####  环形石子合并

解决环形问题方法 开两倍长的数组

```c++
// Problem: 环形石子合并
// Contest: AcWing
// URL: https://www.acwing.com/problem/content/1070/
// Memory Limit: 64 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)
#include <bits/stdc++.h>
using namespace std;
const int N = 410, INF = 0x3f3f3f3f;
int n;
int a[N];
int f[N][N];
int g[N][N];
int sum[N];
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  for (int i = 1; i <= n; i++) {
    a[i + n] = a[i];
  }
  int nn = n * 2;
  for (int i = 1; i <= nn; i++) {
    sum[i] = a[i] + sum[i - 1];
  }

  memset(g, 0x3f, sizeof g);
  for (int i = 1; i <= nn; i++) g[i][i] = 0;
  for (int k = 2; k <= n; k++) {
    for (int l = 1; l <= nn - k + 1; l++) {
      int r = l + k - 1;
      int &x = f[l][r], &y = g[l][r];
      for (int i = l; i < r; i++) {
        x = max(x, f[l][i] + f[i + 1][r] + sum[r] - sum[l - 1]);
        y = min(y, g[l][i] + g[i + 1][r] + sum[r] - sum[l - 1]);
      }
    }
  }
  int resmin = INF, resmax = 0;

  for (int i = 1; i <= nn - n + 1; i++) {
    resmin = min(resmin, g[i][i + n - 1]);
    resmax = max(resmax, f[i][i + n - 1]);
  }
  cout << resmin << endl;
  cout << resmax;

  return 0;
}

```

##### 能量项链

矩阵连乘的环形版本 把所有的系数*2放在一个数组上即可

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 200 + 10;
int n;
int a[N];
int f[N][N];
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
    a[i + n] = a[i];
  }
  for (int len = 3; len <= n + 1; len++) {
    for (int l = 1; l <= 2 * n - len + 1; l++) {
      int r = l + len - 1;
      int &x = f[l][r];
      for (int i = l + 1; i < r; i++) {
        x = max(x, f[l][i] + f[i][r] + a[l] * a[i] * a[r]);
      }
    }
  }
  // cerr << f[4][7] << endl;
  int res = 0;
  for (int i = 1; i <= 2 * n - n - 1 + 1; i++) res = max(res, f[i][i + n]);
  cout << res;

  return 0;
}
```

##### 加分二叉树

考虑**一个区间是一个子树**  **存这个区间的根节点**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 35;
int n, f[N][N], g[N][N];  // f是树的加分总和 g是树的根
struct Node {
  int node_score;
  int l, r;
};
Node a[N];

int solve(int l, int r) {
  if (l == r) return a[l].node_score;
  if (l > r) return 1;
  if (f[l][r] != -1) return f[l][r];
  for (int root = l; root <= r; root++) {
    int left = solve(l, root - 1), right = solve(root + 1, r);
    int &x = f[l][r];
    if (x < left * right + a[root].node_score) {
      x = left * right + a[root].node_score;
      g[l][r] = root;
    }
  }
  return f[l][r];
}

void dfs(int root, int ll, int rr) {
  cout << root << " ";
  int l = root - 1;
  if (l >= ll) {
    int left = g[ll][l];
    dfs(left, ll, l);
  }
  int r = root + 1;
  if (r <= rr) {
    int right = g[r][rr];
    dfs(right, r, rr);
  }
  return;
}
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i].node_score;
  }
  memset(f, -1, sizeof f);
  for (int i = 1; i <= n; i++) f[i][i] = a[i].node_score, g[i][i] = i;

  int res = solve(1, n);
  cout << res << endl;
  int root = g[1][n];
  cerr << g[1][2] << endl;
  dfs(root, 1, n);
  return 0;
}

```

##### 凸多边形的划分

以后再补高精度 TODO: 其实这个不算是环形dp

```c++
#include <bits/stdc++.h>

using namespace std;
typedef int LL;
const int N = 55,INF=0x3f3f3f3f;
int n,a[N];
LL f[N][N];



int main()
{
    cin >> n ;
    for (int i = 1; i <= n; i ++ ){
        cin >> a[i];
    }
    
    for(int len=3;len<=n;len++){
        for(int l=1;l<= n-len+1;l++){
            int r= l+len-1;
            LL &x= f[l][r];
            x=INF;
            for(int mid=l+1;mid<r;mid++){
                x = min(x,f[l][mid]+f[mid][r]+a[l]*a[r]*a[mid]);
            } 
        }
    }
    cout << f[1][n];
}
```

##### 棋盘划分



```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 15, M = 9;  // M是棋盘大小 N是次数
const double INF = 1e9;

int n, m = 8;
int s[M][M];
double f[M][M][M][M][N];
double X;

int get_sum(int x1, int y1, int x2, int y2) {
  return s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1];
}

double get(int x1, int y1, int x2, int y2) {
  double sum = get_sum(x1, y1, x2, y2) - X;
  return (double)sum * sum / n;//方差
}

double dp(int x1, int y1, int x2, int y2, int k) {
  double &v = f[x1][y1][x2][y2][k];
  if (v >= 0) return v;
  if (k == 1) return v = get(x1, y1, x2, y2);//如果只有一个矩形

  v = INF;
  for (int i = x1; i < x2; i++) {//按编程时候的坐标系
    v = min(v, get(x1, y1, i, y2) + dp(i + 1, y1, x2, y2, k - 1));//按x轴切开
    v = min(v, get(i + 1, y1, x2, y2) + dp(x1, y1, i, y2, k - 1));
  }

  for (int i = y1; i < y2; i++) {
    v = min(v, get(x1, y1, x2, i) + dp(x1, i + 1, x2, y2, k - 1));
    v = min(v, get(x1, i + 1, x2, y2) + dp(x1, y1, x2, i, k - 1));
  }

  return v;
}

int main() {
  cin >> n;
  for (int i = 1; i <= m; i++)
    for (int j = 1; j <= m; j++) {
      cin >> s[i][j];
      s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
    }

  X = (double)s[m][m] / n;
  cerr << X;
  memset(f, -1, sizeof f);
  printf("%.3lf\n", sqrt(dp(1, 1, 8, 8, n)));

  return 0;
}
```

#### 树形模型

##### 树的最长路径

**树的直径 最长的一条路径** 

任取一点作为起点 找到距离该店最远的一点u

再找到距离u最远的一点v u和v 之间的路径就是一条直径 DFS **BFS**

```c++
#include <bits/stdc++.h>
#define x first
#define y second
#define eb emplace_back
typedef long long LL;
using namespace std;
const int N = 1e4 + 10;
struct Edge {
  int to, w;
  Edge() {}
  Edge(int _to, int _w) { to = _to, w = _w; }
};
vector<Edge> edges[N];
int n;
int ans;
int dfs(int u, int fa) {
  int dist = 0;
  int d1 = 0, d2 = 0;

  for (auto t : edges[u]) {
    if (t.to == fa) continue;
    int d = dfs(t.to, u) + t.w;
    if (t.to == 6) cerr << t.to << " " << t.w << " " << u << endl;
    dist = max(dist, d);
    if (d >= d1) {
      d2 = d1;
      d1 = d;
    } else if (d > d2)
      d2 = d;
  }
  ans = max(ans, d1 + d2);//d1 + d2表示 挂到uz
  return dist;
}

int main() {
  cin >> n;
  for (int i = 1; i <= n - 1; i++) {
    int a, b, c;
    cin >> a >> b >> c;
    edges[a].eb(b, c);
    edges[b].eb(a, c);
  }
  dfs(1, 0);
  cerr << dfs(6, 1) << endl;
  cout << ans;

  return 0;
}
```

##### 树的中心

求出每个点到其他所有点的最远距离

最远距离有两种 一种从子节点开始 另一种是从父节点开始

```c++
#include <bits/stdc++.h>
#define x first
#define y second
#define eb emplace_back
using namespace std;
const int N = 1e4 + 10, INF = 0x3f3f3f3f;
struct Edge {
  int to, w;
  Edge(int _to, int _w) : to(_to), w(_w) {}
};
vector<Edge> edges[N];
int d1[N], d2[N], p1[N], p2[N];  // p1[i] 记录i节点的最长向下路径的子节点
int up[N];
int n;  //树的边只有节点数-1

int dfs_d(int u, int fa) {
  d1[u] = d2[u] = 0;  //因为权值大于等于0
  for (auto item : edges[u]) {
    int to = item.to, w = item.w;
    if (to == fa) continue;
    int d = dfs_d(to, u) + w;
    if (d >= d1[u]) {
      d2[u] = d1[u], p2[u] = p1[u];
      d1[u] = d, p1[u] = to;
    } else if (d > d2[u]) {
      d2[u] = d, p2[u] = to;
    }
  }
  if (d1[u] == -INF) d1[u] = d2[u] = 0;
  return d1[u];
}
int dfs_u(int u, int fa) {  //
  for (auto item : edges[u]) {
    int to = item.to, w = item.w;
    if (to == fa) continue;
    if (to != p1[u]) {
      up[to] = max(up[u], d1[u]) + w;
    } else {
      up[to] = max(up[u], d2[u]) + w;
    }
    dfs_u(to, u);
  }
  return 0;
}

int main() {
  cin >> n;
  for (int i = 1; i <= n - 1; i++) {
    int a, b, c;
    cin >> a >> b >> c;
    edges[a].eb(b, c), edges[b].eb(a, c);
  }
  dfs_d(1, 0);
  up[1] = 0;  //假设1号点是根节点
  dfs_u(1, 0);
  int res = INF;

  for (int i = 1; i <= n; i++) res = min(res, max(d1[i], up[i]));
  cout << res;
  return 0;
}
```







### 杂题

##### 鸡蛋的硬度

如果鸡蛋个数无限 尝试的次数是logn 但是鸡蛋个数受限

条件 m个鸡蛋 n层楼

最优化 扔的次数 f[i] [j] i层楼 j个鸡蛋 仍的次数 或者 f[i] [j] 扔i次 j个鸡蛋 可以的层数

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=110,M=15,INF=0x3f3f3f3f;
int n,m,f[N][M];
int solve(int n,int m){//n是楼高 m是鸡蛋数
    if(f[n][m]!=-1)return f[n][m];
    if(n==0)return f[n][m]=n;
    if(m==1)return f[n][m]=n;
    int res = INF;
    for (int i = 1; i <= n; i ++ ){
        int rest=max(solve(i-1,m-1)+1,solve(n-i,m)+1);
        res=min(res,rest);
    }
    return f[n][m]=res;
}
int main()
{
    memset(f, -1, sizeof f);
    while(scanf("%d%d",&n,&m)==2){
        cout << solve(n,m)<<endl;
    }
}
```

f[i, j]表示用j个鸡蛋测量i次能测量的区间长度的最大值
枚举扔鸡蛋的楼层k，类似dp1，没碎测k楼以上，碎了测k楼以下，那么能测的最大高度就是上下两部分加上第k层楼这一层

```c++
#include <iostream>
using namespace std;

int f[110][15], n, m;

int main() {
    while (cin >> n >> m) {
        for (int i = 1; i <= n; i ++ ) {
            for (int j = 1; j <= m; j ++ )
                f[i][j] = f[i - 1][j] + f[i - 1][j - 1] + 1;
            if (f[i][m] >= n) {
                cout << i << endl;
                break;
            }
        }
    }
    return 0;
}
```

 
