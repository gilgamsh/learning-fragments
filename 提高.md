### DP

#### 数字三角形模型

##### 摘花生

网格 左上到右下 不走回头路 求最大值

1. dp 阶段、决策 最优子结构 无后效性

2. 从集合角度来考虑dp问题 
   1. 状态表示 f[i,j] 
      1. 集合 所有从(1,1)走到(i,j)的路线（以左上为原点  x向下 y向右 和打印顺序一样）
      2. 属性 Max/Min/数量
      
   2. 状态计算 常用的**划分依据**  “最后一步”  **划分原则** 不漏 不重复
   
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 110;
int a[N][N];
LL f[N][N];
void solve(){
    int r,c; cin >> r>>c;
    memset(a,0,sizeof a);
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            cin >> a[i][j];
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j]; //
    cout << f[r][c]<<endl;
}
int main()
{
    int t;cin >> t;
    for (int i = 1; i <= t; i ++ )solve();
} 
```

##### 最低通行费

网格  左上到右下 不走回头路 求最小值

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int a[N][N];
int f[N][N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            cin >> a[i][j];
    for (int i = 1; i <= n; i ++ )f[i][1]=f[i-1][1]+a[i][1];
    for (int i = 1; i <= n; i ++ )f[1][i]=f[1][i-1]+a[1][i];
    for (int i=2;i<=n;i++)
        for (int j = 2; j <= n; j ++ )
            f[i][j]=min(f[i-1][j],f[i][j-1])+a[i][j];
    cout << f[n][n];
}
```

##### 方格取数      

方格 左上到右下 不走回头路  走两次 两次相关 同时枚举 最后一步的情况是四种 当两条路径重合的时候 

**格子值只会被计算一次** 可以重合 但是值只算一次 所以计算f数组的值的时候 需要考虑两条路径是不是有重合 **而只有两个路线的步数一致时 才有可能重合。所以用K表示步数**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 20;
int a[N][N];
int f[2*20][N][N];
int main()
{
    int n;cin>>n;
    int r=1,c,num;
    while(r!=0){
        cin >> r>>c>>num;
        if(r==0)break;
        a[r][c]=num;
    }
    f[2][1][1]=a[1][1];
    for(int k=3;k<=2*n;k++){
        for(int i=1;i<k&&i<=n;i++){
            for(int j=1;j<k&&j<=n;j++){
                int t =a[i][k-i];
                if(i!=j) t+=a[j][k-j];
                int & tmp=f[k][i][j];
                tmp=max(tmp,f[k-1][i-1][j]+t);
                tmp=max(tmp,f[k-1][i-1][j-1]+t);
                tmp=max(tmp,f[k-1][i][j-1]+t);
                tmp=max(tmp,f[k-1][i][j]+t);
            }
        }
    }
    cout << f[2*n][n][n];
}
```

##### 传纸条

网格 左上到右下 两条 不能重复 求路径上的最大值

状态表示是有意义的 **可以推出答案** **每个状态可被计算**  和方格取数本质上一样 方格取数中 两条路径也不会有交点

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 55;
int a[N][N];
int f[2*N][N][N];
int main()
{
    int m,n;cin>>m>>n;
    for (int i = 1; i <= m; i ++ ){
        for (int j = 1; j <= n; j ++ ){
            cin >> a[i][j];
        }
    }
    f[2][1][1]=a[1][1];
    for(int k=3;k<=m+n;k++){
        for(int i=1;i<k&&i<=m;i++){
            for(int j=1;j<k&&j<=m;j++){
                if(k!=m+n && i==j)continue;
                int t =a[i][k-i];
                t+=a[j][k-j];
                int &tmp=f[k][i][j];
                tmp=max(tmp,f[k-1][i-1][j]+t);
                tmp=max(tmp,f[k-1][i-1][j-1]+t);
                tmp=max(tmp,f[k-1][i][j-1]+t);
                tmp=max(tmp,f[k-1][i][j]+t);
            }
        }
    }
    //cout<<f[5][2][3]<<endl;
    
    cout << f[m+n-1][m][m-1];
}
```

#### 最长上升子序列模型

##### 怪盗基德的滑翔翼

注意可以从两端算起 $$O(n^2)$$做法

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 110;
int a[N];
int f[N];
void solve(){
    memset(a, 0, sizeof a);
    memset(f, 0, sizeof f);
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }
    for (int i = 1; i <= n; i ++ )f[i]=1;
    for (int i = 1; i <= n; i ++ ){
        for (int j = 1; j < i; j ++ ){
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    memset(f, 0, sizeof f);
    for (int i = n; i >= 1; i -- )f[i]=1;
    for (int i = n; i >= 1; i -- ){
        for (int j = n; j > i; j -- ){
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout<<res<<endl;
}

int main()
{
    int k;cin>>k;
    for (int i = 1; i <= k; i ++ )solve();
}
```

##### 登山

先求最长上升 再求最长下降 然后两个状态重叠

1. 编号递增 子序列
2. 一旦开始下降就不难上升 先上升再下降

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N],f[N],g[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin >> a[i],f[i]=g[i]=1;
    for (int i = 1; i <= n; i ++ ){
        for (int j = 1; j < i; j ++ ){
            if(a[j]<a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for (int i = n; i >= 1; i -- ){
        for (int j = n; j > i; j -- ){
            if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]+g[i]-1);
    cout << res <<endl;
}
```

##### 合唱队形

序列 求最长上升和最长下降 然后取一个总和的状态 上面的对偶问题

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int a[N];
int f[N],g[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin >>a[i];
    for(int i=1;i<=n;i++){
        f[i]=1;
        for (int j = 1; j < i; j ++ ){
            if(a[j]<a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for(int i=n;i>=1;i--){
        g[i]=1;
        for (int j = n; j > i; j -- ){
            if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]+g[i]-1);
    cout << n-res;
}
```

##### 友好城市

要保证没有交集，那么就需要保证上下两个序列均为上升的 排序了下面的序列，那么就已经能保证下方的序列为上升的，在这个的前提下就可以将这个题目转换为求最长上升子序列

```c++
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
const int N = 5010;
typedef pair<int,int> PII;
PII a[N];
int b[N],f[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ ){
        int x,y;cin>>x>>y;
        a[i]={x,y};
    }
    sort(a+1,a+n+1);
    for (int i = 1; i <= n; i ++ )b[i]=a[i].y;
    for (int i = 1; i <= n; i ++ ){
        f[i]=1;
        for (int j = 1; j < i; j ++ )
            if(b[j]<=b[i])f[i]=max(f[i],f[j]+1);
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout << res;
}
```

##### 最大上升子序列和

维护的属性变成最大上升子序列的和的最大值

```c++
#include <bits/stdc++.h>
using namespace std;
const int N=1010;
int a[N],f[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin>>a[i];
    for (int i = 1; i <= n; i ++ ){
        f[i]=a[i];
        for (int j = 1; j < i; j ++ )
            if(a[j]<a[i])f[i]=max(f[i],f[j]+a[i]);
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout << res;
}
```

##### 拦截导弹

Dilworth定理：偏序集的最少反链划分数等于最长链的长度，说简单点其实就是第二问相当于求最长上升子序列

具体动机 如下

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323204343366.png" alt="image-20220323204343366" style="zoom: 80%;" />

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323204412485.png" alt="image-20220323204412485" style="zoom:80%;" />

调整的方法在于 将第一个不同的数交换 可以将贪心法找到的解调整为最优解 并且每次调整没有增加解的个数

贪心的过程类似于

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N],idx,f[N],g[N];
int main()
{
    int tmp;
    while(scanf("%d",&tmp)==1){
        a[++idx]=tmp;
    }
    for (int i = 1; i <= idx; i ++ ){
        f[i]=1;
        for (int j = 1; j < i; j ++ )
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
    }
    for (int i = 1; i <= idx; i ++ ){
        g[i]=1;
        for (int j = 1; j < i; j ++ )
        if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
    }
    int res1=0,res2=0;
    for (int i = 1; i <= idx; i ++ )res1=max(res1,f[i]);
    for (int i = 1; i <= idx; i ++ )res2=max(res2,g[i]);
    cout << res1<<endl;
    cout << res2;
}
```

##### 导弹防御体系

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323214812369.png" alt="image-20220323214812369" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 55;
int n,a[N],up[N],down[N];
bool dfs(int depth,int id,int u,int d)//u是上升子序列的数目 d是下降子序列的数目  i是当前需要处理的数字的序号
{
    if(u+d>depth)return false;
    if(n+1==id)return true;//当要处理的下标越界时 处理完毕了
    
    //枚举放入最长上升子序列的情况  up数组单减 
    bool flag=false;
    for(int i=1;i<=u;i++){
        if(up[i]<a[id]){
            int t=up[i];//u[i]旧值 用于回溯
            up[i]=a[id];
            if(dfs(depth,id+1,u,d))return true;
            flag=true;
            up[i]=t;
            break;
        }
    }
    if(!flag){
        up[u+1]=a[id];
        if(dfs(depth,id+1,u+1,d))return true;
    }
    
    flag=false;
    for(int i=1;i<=d;i++){//down 数组单增
        if(down[i]>a[id]){
            int t=down[i];
            down[i]=a[id];
            if(dfs(depth,id+1,u,d))return true;
            flag=true;
            down[i]=t;
            break;
        }
    }
    if(!flag){
        down[d+1]=a[id];
        if(dfs(depth,id+1,u,d+1))return true;
    }
    return false;
}

void solve(){
    int depth=0;
    while(!dfs(depth,1,0,0))depth++;
    cout << depth<<endl;
}

int main()
{
    cin>>n;
    while(n!=0){
        memset(a,0,sizeof a);
        for (int i = 1; i <= n; i ++ )cin>>a[i];
        solve();
        cin >> n;
    }
}
```

