### DP

#### 数字三角形模型

##### 摘花生

网格 左上到右下 不走回头路 求最大值

1. dp 阶段、决策 最优子结构 无后效性

2. 从集合角度来考虑dp问题 
   1. 状态表示 f[i,j] 
      1. 集合 所有从(1,1)走到(i,j)的路线（以左上为原点  x向下 y向右 和打印顺序一样）
      2. 属性 Max/Min/数量
      
   2. 状态计算 常用的**划分依据**  “最后一步”  **划分原则** 不漏 不重复
   
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 110;
int a[N][N];
LL f[N][N];
void solve(){
    int r,c; cin >> r>>c;
    memset(a,0,sizeof a);
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            cin >> a[i][j];
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j]; //
    cout << f[r][c]<<endl;
}
int main()
{
    int t;cin >> t;
    for (int i = 1; i <= t; i ++ )solve();
} 
```

##### 最低通行费

网格  左上到右下 不走回头路 求最小值

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int a[N][N];
int f[N][N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            cin >> a[i][j];
    for (int i = 1; i <= n; i ++ )f[i][1]=f[i-1][1]+a[i][1];
    for (int i = 1; i <= n; i ++ )f[1][i]=f[1][i-1]+a[1][i];
    for (int i=2;i<=n;i++)
        for (int j = 2; j <= n; j ++ )
            f[i][j]=min(f[i-1][j],f[i][j-1])+a[i][j];
    cout << f[n][n];
}
```

##### 方格取数      

方格 左上到右下 不走回头路  走两次 两次相关 同时枚举 最后一步的情况是四种 当两条路径重合的时候 

**格子值只会被计算一次** 可以重合 但是值只算一次 所以计算f数组的值的时候 需要考虑两条路径是不是有重合 **而只有两个路线的步数一致时 才有可能重合。所以用K表示步数**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 20;
int a[N][N];
int f[2*20][N][N];
int main()
{
    int n;cin>>n;
    int r=1,c,num;
    while(r!=0){
        cin >> r>>c>>num;
        if(r==0)break;
        a[r][c]=num;
    }
    f[2][1][1]=a[1][1];
    for(int k=3;k<=2*n;k++){
        for(int i=1;i<k&&i<=n;i++){
            for(int j=1;j<k&&j<=n;j++){
                int t =a[i][k-i];
                if(i!=j) t+=a[j][k-j];
                int & tmp=f[k][i][j];
                tmp=max(tmp,f[k-1][i-1][j]+t);
                tmp=max(tmp,f[k-1][i-1][j-1]+t);
                tmp=max(tmp,f[k-1][i][j-1]+t);
                tmp=max(tmp,f[k-1][i][j]+t);
            }
        }
    }
    cout << f[2*n][n][n];
}
```

##### 传纸条

网格 左上到右下 两条 不能重复 求路径上的最大值

状态表示是有意义的 **可以推出答案** **每个状态可被计算**  和方格取数本质上一样 方格取数中 两条路径也不会有交点

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 55;
int a[N][N];
int f[2*N][N][N];
int main()
{
    int m,n;cin>>m>>n;
    for (int i = 1; i <= m; i ++ ){
        for (int j = 1; j <= n; j ++ ){
            cin >> a[i][j];
        }
    }
    f[2][1][1]=a[1][1];
    for(int k=3;k<=m+n;k++){
        for(int i=1;i<k&&i<=m;i++){
            for(int j=1;j<k&&j<=m;j++){
                if(k!=m+n && i==j)continue;
                int t =a[i][k-i];
                t+=a[j][k-j];
                int &tmp=f[k][i][j];
                tmp=max(tmp,f[k-1][i-1][j]+t);
                tmp=max(tmp,f[k-1][i-1][j-1]+t);
                tmp=max(tmp,f[k-1][i][j-1]+t);
                tmp=max(tmp,f[k-1][i][j]+t);
            }
        }
    }
    //cout<<f[5][2][3]<<endl;
    
    cout << f[m+n-1][m][m-1];
}
```

#### 最长上升子序列模型

##### 怪盗基德的滑翔翼

注意可以从两端算起 $$O(n^2)$$做法

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 110;
int a[N];
int f[N];
void solve(){
    memset(a, 0, sizeof a);
    memset(f, 0, sizeof f);
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }
    for (int i = 1; i <= n; i ++ )f[i]=1;
    for (int i = 1; i <= n; i ++ ){
        for (int j = 1; j < i; j ++ ){
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    memset(f, 0, sizeof f);
    for (int i = n; i >= 1; i -- )f[i]=1;
    for (int i = n; i >= 1; i -- ){
        for (int j = n; j > i; j -- ){
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout<<res<<endl;
}

int main()
{
    int k;cin>>k;
    for (int i = 1; i <= k; i ++ )solve();
}
```

##### 登山

先求最长上升 再求最长下降 然后两个状态重叠

1. 编号递增 子序列
2. 一旦开始下降就不难上升 先上升再下降

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N],f[N],g[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin >> a[i],f[i]=g[i]=1;
    for (int i = 1; i <= n; i ++ ){
        for (int j = 1; j < i; j ++ ){
            if(a[j]<a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for (int i = n; i >= 1; i -- ){
        for (int j = n; j > i; j -- ){
            if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]+g[i]-1);
    cout << res <<endl;
}
```

##### 合唱队形

序列 求最长上升和最长下降 然后取一个总和的状态 上面的对偶问题

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int a[N];
int f[N],g[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin >>a[i];
    for(int i=1;i<=n;i++){
        f[i]=1;
        for (int j = 1; j < i; j ++ ){
            if(a[j]<a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for(int i=n;i>=1;i--){
        g[i]=1;
        for (int j = n; j > i; j -- ){
            if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]+g[i]-1);
    cout << n-res;
}
```

##### 友好城市

要保证没有交集，那么就需要保证上下两个序列均为上升的 排序了下面的序列，那么就已经能保证下方的序列为上升的，在这个的前提下就可以将这个题目转换为求最长上升子序列

```c++
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
const int N = 5010;
typedef pair<int,int> PII;
PII a[N];
int b[N],f[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ ){
        int x,y;cin>>x>>y;
        a[i]={x,y};
    }
    sort(a+1,a+n+1);
    for (int i = 1; i <= n; i ++ )b[i]=a[i].y;
    for (int i = 1; i <= n; i ++ ){
        f[i]=1;
        for (int j = 1; j < i; j ++ )
            if(b[j]<=b[i])f[i]=max(f[i],f[j]+1);
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout << res;
}
```

##### 最大上升子序列和

维护的属性变成最大上升子序列的和的最大值

```c++
#include <bits/stdc++.h>
using namespace std;
const int N=1010;
int a[N],f[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin>>a[i];
    for (int i = 1; i <= n; i ++ ){
        f[i]=a[i];
        for (int j = 1; j < i; j ++ )
            if(a[j]<a[i])f[i]=max(f[i],f[j]+a[i]);
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout << res;
}
```

##### 拦截导弹

Dilworth定理：偏序集的最少反链划分数等于最长链的长度，说简单点其实就是第二问相当于求最长上升子序列

具体动机 如下

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323204343366.png" alt="image-20220323204343366" style="zoom: 80%;" />

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323204412485.png" alt="image-20220323204412485" style="zoom:80%;" />

调整的方法在于 将第一个不同的数交换 可以将贪心法找到的解调整为最优解 并且每次调整没有增加解的个数

贪心的过程类似于

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N],idx,f[N],g[N];
int main()
{
    int tmp;
    while(scanf("%d",&tmp)==1){
        a[++idx]=tmp;
    }
    for (int i = 1; i <= idx; i ++ ){
        f[i]=1;
        for (int j = 1; j < i; j ++ )
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
    }
    for (int i = 1; i <= idx; i ++ ){
        g[i]=1;
        for (int j = 1; j < i; j ++ )
        if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
    }
    int res1=0,res2=0;
    for (int i = 1; i <= idx; i ++ )res1=max(res1,f[i]);
    for (int i = 1; i <= idx; i ++ )res2=max(res2,g[i]);
    cout << res1<<endl;
    cout << res2;
}
```

##### 导弹防御体系

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323214812369.png" alt="image-20220323214812369" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 55;
int n,a[N],up[N],down[N];
bool dfs(int depth,int id,int u,int d)//u是上升子序列的数目 d是下降子序列的数目  i是当前需要处理的数字的序号
{
    if(u+d>depth)return false;
    if(n+1==id)return true;//当要处理的下标越界时 处理完毕了
    
    //枚举放入最长上升子序列的情况  up数组单减 
    bool flag=false;
    for(int i=1;i<=u;i++){
        if(up[i]<a[id]){
            int t=up[i];//u[i]旧值 用于回溯
            up[i]=a[id];
            if(dfs(depth,id+1,u,d))return true;
            flag=true;
            up[i]=t;
            break;
        }
    }
    if(!flag){
        up[u+1]=a[id];
        if(dfs(depth,id+1,u+1,d))return true;
    }
    
    flag=false;
    for(int i=1;i<=d;i++){//down 数组单增
        if(down[i]>a[id]){
            int t=down[i];
            down[i]=a[id];
            if(dfs(depth,id+1,u,d))return true;
            flag=true;
            down[i]=t;
            break;
        }
    }
    if(!flag){
        down[d+1]=a[id];
        if(dfs(depth,id+1,u,d+1))return true;
    }
    return false;
}

void solve(){
    int depth=0;
    while(!dfs(depth,1,0,0))depth++;
    cout << depth<<endl;
}

int main()
{
    cin>>n;
    while(n!=0){
        memset(a,0,sizeof a);
        for (int i = 1; i <= n; i ++ )cin>>a[i];
        solve();
        cin >> n;
    }
}
```

##### 最长上升公共子序列

不能先求公共子序列 再求上升自序列 

反例 

5

5 3 2 1 4    最长的公共自序列是 5 4 或者 3 4等等

3 5 4 2 1 

注意此例

10
1 5 3 6 3 2 7 3 6 2 
9 6 2 3 1 5 3 3 6 1  考虑f[1] [5]

![image-20220324205252518](C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220324205252518.png)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3010;
int n, a[N], b[N], f[N][N];
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> a[i];
  for (int i = 1; i <= n; i++) cin >> b[i];
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      int &x = f[i][j];
      x = f[i - 1][j];
      if (a[i] == b[j]){
          if(i==1&&j==5)cout<<a[i]<<" "<<b[j]<<endl;
         x=1;
        for (int k = 1; k < j; k++) {
          if (b[k] < b[j]) x = max(x, f[i - 1][k] + 1);
        }
        }
    }
  }
  int res = 0;
  for(int i=1;i<=n;i++){
      for (int j = 1; j <= n; j ++ ){
          cout << f[i][j]<<" ";
      }
      puts("");
  }
  cout << res;
}
```

然后我们发现每次循环求得的maxv是满足a[i] > b[k]的f[i - 1] [k] + 1的前缀最大值。
因此可以直接将maxv提到第一层循环外面，减少重复计算，此时只剩下两重循环。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3010;
int n, a[N], b[N], f[N][N];
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> a[i];
  for (int i = 1; i <= n; i++) cin >> b[i];
  
  for (int i = 1; i <= n; i++) {
    int maxv=0;//记录 f[i-1][j]的前j个数的最大值
    for (int j = 1; j <= n; j++) {//此时maxv的值是f[i-1][j-1]的前缀最大值
      int &x = f[i][j];
      x = f[i - 1][j];
      if (a[i] == b[j]){
        x=max(x,maxv+1);    //第j个在
      }
      if(a[i]>b[j])maxv=max(maxv,f[i-1][j]);//更新f[i-1][j]的前缀最大值
    }
  }
  int res = 0;
  for(int i=1;i<=n;i++){
      for (int j = 1; j <= n; j ++ ){
          res=max(res,f[i][j]);
      }
  }
  cout << res;
}
```

#### 背包

##### 采药

如果 不能放下第j个 也要记得更新

```c++
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 110,M=1010;
PII a[N];
int t,m;
int f[N][M];
int main()
{
    cin >> t>>m;
    for (int i = 1; i <= m; i ++ )cin>>a[i].x>>a[i].y;
    for (int i = 1; i <= m; i ++ ){
        int tt=a[i].x,nn=a[i].y;
        for(int j=1;j<=t;j++){
            f[i][j]=f[i-1][j];
            if(j>=tt)f[i][j]=max(f[i-1][j],f[i-1][j-tt]+nn);
        }
    }
    cout << f[m][t];
}
```

##### 装箱问题

题目里面 价值 和 体积是值一样

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 40,V=20010;
int v,n;
int a[N],f[N][V];
int main()
{
    cin >> v>>n;
    for (int i = 1; i <= n; i ++ ) cin>>a[i];
    for (int i = 1; i <= n; i ++ ) f[i][0]=1,f[i][a[i]]=1;
    
    for (int i = 1; i <= n; i ++ ){
        for (int j = 0; j <= v; j ++ ){
            if(f[i-1][j])f[i][j]=1;
            if(f[i-1][j]&&j+a[i]<=v)f[i][j+a[i]]=1;
        }
    }
    int res=0;
    for (int j = 0; j <= v; j ++ )if(f[n][j])res=j;
    cout << v-res;
}
```

##### 宠物小精灵之收服

在背包问题中，体积w与价值v是可以互逆的！
可以将f[i]表示为体积为i能装的最大价值，也可以将f[i]表示为价值为i所需的最小体积。
两者等价，我们只需要选择范围较小的那维作为体积就可以了！ 这直接影响到时空复杂度。

朴素的二维的dp

```c++
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 1010, M = 510, K = 110;
PII a[K];
int n, m, k, f[2][M][N];
int main() {
  cin >> n >> m >> k;
  for (int i = 1; i <= k; i++) {
    cin >> a[i].x >> a[i].y;
  }
  for (int i = 1; i <= k; i++) {      //枚举k个小精灵
    for (int j = 0; j < m; j++) {     // j是体力值
      for (int w = 0; w <= n; w++) {  // w是精灵球的数量
        int ww = a[i].x, jj = a[i].y;
        int &x = f[i % 2][j][w];
        x = f[(i - 1) % 2][j][w];
        if (w >= ww && j >= jj) x = max(x, f[(i - 1) % 2][j - jj][w - ww] + 1);
      }
    }
  }
  int c = 0, r = m;
  for (int i = 0; i < m; i++) {
    for (int j = 0; j <= n; j++) {
      if (f[k % 2][i][j] > c) {
        c = f[k % 2][i][j];
        r = m - i;
      }
      if (f[k % 2][i][j] == c) {
        r = max(r, m - i);
      }
    }
  }
  cout << c << " " << r;
  return 0;
}
```

优化做法  太痛苦了 忘记初始化了 如果

```c++
// Problem: 宠物小精灵之收服
// Contest: AcWing
// URL: https://www.acwing.com/problem/content/1024/
// Memory Limit: 64 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 1010, M = 510, K = 110, INF = 0x3f3f3f3f;
PII a[K];
int n, m, k, f[2][M][K];
int main() {
  memset(f, 0x3f, sizeof f);
  cin >> n >> m >> k;
  for (int i = 1; i <= k; i++) {
    cin >> a[i].x >> a[i].y;
  }
  memset(f, 0x3f, sizeof f);
  f[0][0][0] = 0;                     //不抓小精灵肯定不用精灵球
  f[1][0][0] = 0;                     //不抓小精灵不用精灵球
  for (int i = 1; i <= k; i++) {      //枚举考虑第i个小精灵
    for (int j = 0; j < m; j++) {     //花费了m体力
      for (int w = 0; w <= i; w++) {  //抓了i个小精灵
        int &t = f[(i) % 2][j][w];
        t = f[(i - 1) % 2][j][w];  //最少多少精灵球
        int nn = a[i].x, tt = a[i].y;
        if (j >= tt && w >= 1 && f[(i - 1) % 2][j - tt][w - 1] + nn <= n)
          t = min(t, f[(i - 1) % 2][j - tt][w - 1] + nn);
        if (j == 50 && w == 2) cerr << f[i % 2][j][w] << " ";
      }
    }
  }
  int c = 0, r = m;
  for (int i = 0; i < m; i++) {
    for (int j = 1; j <= k; j++) {
      if (f[(k) % 2][i][j] <= n) {
        if (c < j)
          r = m - i, c = j;
        else if (c == j)
          r = max(r, m - i);
      }
    }
  }

  cout << c << " " << r;
  return 0;
}
```

##### 数字组合

M看成是背包容量 每个数是一个物品 Ai是体积 总体积恰好是M的方案数

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220325153819418.png" alt="image-20220325153819418" style="zoom:80%;" />

```c++
//已知 有n个数 目标是和为n  求最大方案数
#include <bits/stdc++.h>
using namespace std;
const int N = 110, M = 10010;
int n, m, a[N], f[N][M];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) cin >> a[i];

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      int &x = f[i][j];
      x = f[i - 1][j];  //不用第i个数
      if (j > a[i])
        x += f[i - 1][j - a[i]];  //用第i个数
      else if(j==a[i])
        x += 1;
    }
  }
  cout << f[n][m];

  return 0;
}
```

##### 买书

完全背包问题 变成了方案数  需要把n元全部花完

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[5]={0,10,20,50,100},n;
int f[2][N];
int main()
{
    cin >> n;
    f[0][0]=f[1][0]=1;
    for (int i = 1; i <= 4; i ++ ){
        for (int j = 0; j <= n; j ++ ){
            int &x=f[i%2][j];
            x=f[(i-1)%2][j];//不买第i本书
            if(j>a[i])x+=f[(i)%2][j-a[i]];
            else if(j==a[i])x+=1;
        }
    }
    cout<<f[4%2][n];
}
```



### 杂题

##### 鸡蛋的硬度

如果鸡蛋个数无限 尝试的次数是logn 但是鸡蛋个数受限

条件 m个鸡蛋 n层楼

最优化 扔的次数 f[i] [j] i层楼 j个鸡蛋 仍的次数 或者 f[i] [j] 扔i次 j个鸡蛋 可以的层数

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=110,M=15,INF=0x3f3f3f3f;
int n,m,f[N][M];
int solve(int n,int m){//n是楼高 m是鸡蛋数
    if(f[n][m]!=-1)return f[n][m];
    if(n==0)return f[n][m]=n;
    if(m==1)return f[n][m]=n;
    int res = INF;
    for (int i = 1; i <= n; i ++ ){
        int rest=max(solve(i-1,m-1)+1,solve(n-i,m)+1);
        res=min(res,rest);
    }
    return f[n][m]=res;
}
int main()
{
    memset(f, -1, sizeof f);
    while(scanf("%d%d",&n,&m)==2){
        cout << solve(n,m)<<endl;
    }
}
```

f[i, j]表示用j个鸡蛋测量i次能测量的区间长度的最大值
枚举扔鸡蛋的楼层k，类似dp1，没碎测k楼以上，碎了测k楼以下，那么能测的最大高度就是上下两部分加上第k层楼这一层

```c++
#include <iostream>
using namespace std;

int f[110][15], n, m;

int main() {
    while (cin >> n >> m) {
        for (int i = 1; i <= n; i ++ ) {
            for (int j = 1; j <= m; j ++ )
                f[i][j] = f[i - 1][j] + f[i - 1][j - 1] + 1;
            if (f[i][m] >= n) {
                cout << i << endl;
                break;
            }
        }
    }
    return 0;
}
```

### 
