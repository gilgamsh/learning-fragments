### DP

#### 数字三角形模型

##### 摘花生

网格 左上到右下 不走回头路 求最大值

1. dp 阶段、决策 最优子结构 无后效性

2. 从集合角度来考虑dp问题 
   1. 状态表示 f[i,j] 
      1. 集合 所有从(1,1)走到(i,j)的路线（以左上为原点  x向下 y向右 和打印顺序一样）
      2. 属性 Max/Min/数量
      
   2. 状态计算 常用的**划分依据**  “最后一步”  **划分原则** 不漏 不重复
   
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 110;
int a[N][N];
LL f[N][N];
void solve(){
    int r,c; cin >> r>>c;
    memset(a,0,sizeof a);
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            cin >> a[i][j];
    for(int i=1;i<=r;i++)
        for(int j=1;j<=c;j++)
            f[i][j]=max(f[i-1][j],f[i][j-1])+a[i][j]; //
    cout << f[r][c]<<endl;
}
int main()
{
    int t;cin >> t;
    for (int i = 1; i <= t; i ++ )solve();
} 
```

##### 最低通行费

网格  左上到右下 不走回头路 求最小值

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int a[N][N];
int f[N][N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            cin >> a[i][j];
    for (int i = 1; i <= n; i ++ )f[i][1]=f[i-1][1]+a[i][1];
    for (int i = 1; i <= n; i ++ )f[1][i]=f[1][i-1]+a[1][i];
    for (int i=2;i<=n;i++)
        for (int j = 2; j <= n; j ++ )
            f[i][j]=min(f[i-1][j],f[i][j-1])+a[i][j];
    cout << f[n][n];
}
```

##### 方格取数      

方格 左上到右下 不走回头路  走两次 两次相关 同时枚举 最后一步的情况是四种 当两条路径重合的时候 

**格子值只会被计算一次** 可以重合 但是值只算一次 所以计算f数组的值的时候 需要考虑两条路径是不是有重合 **而只有两个路线的步数一致时 才有可能重合。所以用K表示步数**

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 20;
int a[N][N];
int f[2*20][N][N];
int main()
{
    int n;cin>>n;
    int r=1,c,num;
    while(r!=0){
        cin >> r>>c>>num;
        if(r==0)break;
        a[r][c]=num;
    }
    f[2][1][1]=a[1][1];
    for(int k=3;k<=2*n;k++){
        for(int i=1;i<k&&i<=n;i++){
            for(int j=1;j<k&&j<=n;j++){
                int t =a[i][k-i];
                if(i!=j) t+=a[j][k-j];
                int & tmp=f[k][i][j];
                tmp=max(tmp,f[k-1][i-1][j]+t);
                tmp=max(tmp,f[k-1][i-1][j-1]+t);
                tmp=max(tmp,f[k-1][i][j-1]+t);
                tmp=max(tmp,f[k-1][i][j]+t);
            }
        }
    }
    cout << f[2*n][n][n];
}
```

##### 传纸条

网格 左上到右下 两条 不能重复 求路径上的最大值

状态表示是有意义的 **可以推出答案** **每个状态可被计算**  和方格取数本质上一样 方格取数中 两条路径也不会有交点

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 55;
int a[N][N];
int f[2*N][N][N];
int main()
{
    int m,n;cin>>m>>n;
    for (int i = 1; i <= m; i ++ ){
        for (int j = 1; j <= n; j ++ ){
            cin >> a[i][j];
        }
    }
    f[2][1][1]=a[1][1];
    for(int k=3;k<=m+n;k++){
        for(int i=1;i<k&&i<=m;i++){
            for(int j=1;j<k&&j<=m;j++){
                if(k!=m+n && i==j)continue;
                int t =a[i][k-i];
                t+=a[j][k-j];
                int &tmp=f[k][i][j];
                tmp=max(tmp,f[k-1][i-1][j]+t);
                tmp=max(tmp,f[k-1][i-1][j-1]+t);
                tmp=max(tmp,f[k-1][i][j-1]+t);
                tmp=max(tmp,f[k-1][i][j]+t);
            }
        }
    }
    //cout<<f[5][2][3]<<endl;
    
    cout << f[m+n-1][m][m-1];
}
```

#### 最长上升子序列模型

##### 怪盗基德的滑翔翼

注意可以从两端算起 $$O(n^2)$$做法

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 110;
int a[N];
int f[N];
void solve(){
    memset(a, 0, sizeof a);
    memset(f, 0, sizeof f);
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        cin >> a[i];
    }
    for (int i = 1; i <= n; i ++ )f[i]=1;
    for (int i = 1; i <= n; i ++ ){
        for (int j = 1; j < i; j ++ ){
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    memset(f, 0, sizeof f);
    for (int i = n; i >= 1; i -- )f[i]=1;
    for (int i = n; i >= 1; i -- ){
        for (int j = n; j > i; j -- ){
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout<<res<<endl;
}

int main()
{
    int k;cin>>k;
    for (int i = 1; i <= k; i ++ )solve();
}
```

##### 登山

先求最长上升 再求最长下降 然后两个状态重叠

1. 编号递增 子序列
2. 一旦开始下降就不难上升 先上升再下降

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N],f[N],g[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin >> a[i],f[i]=g[i]=1;
    for (int i = 1; i <= n; i ++ ){
        for (int j = 1; j < i; j ++ ){
            if(a[j]<a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for (int i = n; i >= 1; i -- ){
        for (int j = n; j > i; j -- ){
            if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]+g[i]-1);
    cout << res <<endl;
}
```

##### 合唱队形

序列 求最长上升和最长下降 然后取一个总和的状态 上面的对偶问题

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int a[N];
int f[N],g[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin >>a[i];
    for(int i=1;i<=n;i++){
        f[i]=1;
        for (int j = 1; j < i; j ++ ){
            if(a[j]<a[i])f[i]=max(f[i],f[j]+1);
        }
    }
    for(int i=n;i>=1;i--){
        g[i]=1;
        for (int j = n; j > i; j -- ){
            if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
        }
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]+g[i]-1);
    cout << n-res;
}
```

##### 友好城市

要保证没有交集，那么就需要保证上下两个序列均为上升的 排序了下面的序列，那么就已经能保证下方的序列为上升的，在这个的前提下就可以将这个题目转换为求最长上升子序列

```c++
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
const int N = 5010;
typedef pair<int,int> PII;
PII a[N];
int b[N],f[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ ){
        int x,y;cin>>x>>y;
        a[i]={x,y};
    }
    sort(a+1,a+n+1);
    for (int i = 1; i <= n; i ++ )b[i]=a[i].y;
    for (int i = 1; i <= n; i ++ ){
        f[i]=1;
        for (int j = 1; j < i; j ++ )
            if(b[j]<=b[i])f[i]=max(f[i],f[j]+1);
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout << res;
}
```

##### 最大上升子序列和

维护的属性变成最大上升子序列的和的最大值

```c++
#include <bits/stdc++.h>
using namespace std;
const int N=1010;
int a[N],f[N];
int main()
{
    int n;cin>>n;
    for (int i = 1; i <= n; i ++ )cin>>a[i];
    for (int i = 1; i <= n; i ++ ){
        f[i]=a[i];
        for (int j = 1; j < i; j ++ )
            if(a[j]<a[i])f[i]=max(f[i],f[j]+a[i]);
    }
    int res=0;
    for (int i = 1; i <= n; i ++ )res=max(res,f[i]);
    cout << res;
}
```

##### 拦截导弹

Dilworth定理：偏序集的最少反链划分数等于最长链的长度，说简单点其实就是第二问相当于求最长上升子序列

具体动机 如下

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323204343366.png" alt="image-20220323204343366" style="zoom: 80%;" />

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323204412485.png" alt="image-20220323204412485" style="zoom:80%;" />

调整的方法在于 将第一个不同的数交换 可以将贪心法找到的解调整为最优解 并且每次调整没有增加解的个数

贪心的过程类似于

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N],idx,f[N],g[N];
int main()
{
    int tmp;
    while(scanf("%d",&tmp)==1){
        a[++idx]=tmp;
    }
    for (int i = 1; i <= idx; i ++ ){
        f[i]=1;
        for (int j = 1; j < i; j ++ )
            if(a[j]>=a[i])f[i]=max(f[i],f[j]+1);
    }
    for (int i = 1; i <= idx; i ++ ){
        g[i]=1;
        for (int j = 1; j < i; j ++ )
        if(a[j]<a[i])g[i]=max(g[i],g[j]+1);
    }
    int res1=0,res2=0;
    for (int i = 1; i <= idx; i ++ )res1=max(res1,f[i]);
    for (int i = 1; i <= idx; i ++ )res2=max(res2,g[i]);
    cout << res1<<endl;
    cout << res2;
}
```

##### 导弹防御体系

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220323214812369.png" alt="image-20220323214812369" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 55;
int n,a[N],up[N],down[N];
bool dfs(int depth,int id,int u,int d)//u是上升子序列的数目 d是下降子序列的数目  i是当前需要处理的数字的序号
{
    if(u+d>depth)return false;
    if(n+1==id)return true;//当要处理的下标越界时 处理完毕了
    
    //枚举放入最长上升子序列的情况  up数组单减 
    bool flag=false;
    for(int i=1;i<=u;i++){
        if(up[i]<a[id]){
            int t=up[i];//u[i]旧值 用于回溯
            up[i]=a[id];
            if(dfs(depth,id+1,u,d))return true;
            flag=true;
            up[i]=t;
            break;
        }
    }
    if(!flag){
        up[u+1]=a[id];
        if(dfs(depth,id+1,u+1,d))return true;
    }
    
    flag=false;
    for(int i=1;i<=d;i++){//down 数组单增
        if(down[i]>a[id]){
            int t=down[i];
            down[i]=a[id];
            if(dfs(depth,id+1,u,d))return true;
            flag=true;
            down[i]=t;
            break;
        }
    }
    if(!flag){
        down[d+1]=a[id];
        if(dfs(depth,id+1,u,d+1))return true;
    }
    return false;
}

void solve(){
    int depth=0;
    while(!dfs(depth,1,0,0))depth++;
    cout << depth<<endl;
}

int main()
{
    cin>>n;
    while(n!=0){
        memset(a,0,sizeof a);
        for (int i = 1; i <= n; i ++ )cin>>a[i];
        solve();
        cin >> n;
    }
}
```

##### 最长上升公共子序列

不能先求公共子序列 再求上升自序列 

反例 

5

5 3 2 1 4    最长的公共自序列是 5 4 或者 3 4等等

3 5 4 2 1 

注意此例

10
1 5 3 6 3 2 7 3 6 2 
9 6 2 3 1 5 3 3 6 1  考虑f[1] [5]

![image-20220324205252518](C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220324205252518.png)

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3010;
int n, a[N], b[N], f[N][N];
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> a[i];
  for (int i = 1; i <= n; i++) cin >> b[i];
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      int &x = f[i][j];
      x = f[i - 1][j];
      if (a[i] == b[j]){
        x=1;
        for (int k = 1; k < j; k++) {
          if (b[k] < b[j]) x = max(x, f[i - 1][k] + 1);
        }
        }
    }
  }
  int res = 0;
  for(int i=1;i<=n;i++){
      for (int j = 1; j <= n; j ++ ){
          cout << f[i][j]<<" ";
      }
      puts("");
  }
  cout << res;
}
```

然后我们发现每次循环求得的maxv是满足a[i] > b[k]的f[i - 1] [k] + 1的前缀最大值。
因此可以直接将maxv提到第一层循环外面，减少重复计算，此时只剩下两重循环。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3010;
int n, a[N], b[N], f[N][N];
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> a[i];
  for (int i = 1; i <= n; i++) cin >> b[i];
  
  for (int i = 1; i <= n; i++) {
    int maxv=0;//记录 f[i-1][j]的前j个数的最大值
    for (int j = 1; j <= n; j++) {//此时maxv的值是f[i-1][j-1]的前缀最大值
      int &x = f[i][j];
      x = f[i - 1][j];
      if (a[i] == b[j]){
        x=max(x,maxv+1);    //第j个在
      }
      if(a[i]>b[j])maxv=max(maxv,f[i-1][j]);//更新f[i-1][j]的前缀最大值
    }
  }
  int res = 0;
  for(int i=1;i<=n;i++){
      for (int j = 1; j <= n; j ++ ){
          res=max(res,f[i][j]);
      }
  }
  cout << res;
}
```

#### 背包

##### 采药

如果 不能放下第j个 也要记得更新

```c++
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 110,M=1010;
PII a[N];
int t,m;
int f[N][M];
int main()
{
    cin >> t>>m;
    for (int i = 1; i <= m; i ++ )cin>>a[i].x>>a[i].y;
    for (int i = 1; i <= m; i ++ ){
        int tt=a[i].x,nn=a[i].y;
        for(int j=1;j<=t;j++){
            f[i][j]=f[i-1][j];
            if(j>=tt)f[i][j]=max(f[i-1][j],f[i-1][j-tt]+nn);
        }
    }
    cout << f[m][t];
}
```

##### 装箱问题

题目里面 价值 和 体积是值一样

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 40,V=20010;
int v,n;
int a[N],f[N][V];
int main()
{
    cin >> v>>n;
    for (int i = 1; i <= n; i ++ ) cin>>a[i];
    for (int i = 1; i <= n; i ++ ) f[i][0]=1,f[i][a[i]]=1;
    
    for (int i = 1; i <= n; i ++ ){
        for (int j = 0; j <= v; j ++ ){
            if(f[i-1][j])f[i][j]=1;
            if(f[i-1][j]&&j+a[i]<=v)f[i][j+a[i]]=1;
        }
    }
    int res=0;
    for (int j = 0; j <= v; j ++ )if(f[n][j])res=j;
    cout << v-res;
}
```

##### 宠物小精灵之收服

在背包问题中，体积w与价值v是可以互逆的！
可以将f[i]表示为体积为i能装的最大价值，也可以将f[i]表示为价值为i所需的最小体积。
两者等价，我们只需要选择范围较小的那维作为体积就可以了！ 这直接影响到时空复杂度。

朴素的二维的dp

```c++
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 1010, M = 510, K = 110;
PII a[K];
int n, m, k, f[2][M][N];
int main() {
  cin >> n >> m >> k;
  for (int i = 1; i <= k; i++) {
    cin >> a[i].x >> a[i].y;
  }
  for (int i = 1; i <= k; i++) {      //枚举k个小精灵
    for (int j = 0; j < m; j++) {     // j是体力值
      for (int w = 0; w <= n; w++) {  // w是精灵球的数量
        int ww = a[i].x, jj = a[i].y;
        int &x = f[i % 2][j][w];
        x = f[(i - 1) % 2][j][w];
        if (w >= ww && j >= jj) x = max(x, f[(i - 1) % 2][j - jj][w - ww] + 1);
      }
    }
  }
  int c = 0, r = m;
  for (int i = 0; i < m; i++) {
    for (int j = 0; j <= n; j++) {
      if (f[k % 2][i][j] > c) {
        c = f[k % 2][i][j];
        r = m - i;
      }
      if (f[k % 2][i][j] == c) {
        r = max(r, m - i);
      }
    }
  }
  cout << c << " " << r;
  return 0;
}
```

优化做法  太痛苦了 忘记初始化了 如果

```c++
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;
typedef pair<int, int> PII;
const int N = 1010, M = 510, K = 110, INF = 0x3f3f3f3f;
PII a[K];
int n, m, k, f[2][M][K];
int main() {
  memset(f, 0x3f, sizeof f);
  cin >> n >> m >> k;
  for (int i = 1; i <= k; i++) {
    cin >> a[i].x >> a[i].y;
  }
  memset(f, 0x3f, sizeof f);
  f[0][0][0] = 0;                     //不抓小精灵肯定不用精灵球
  f[1][0][0] = 0;                     //不抓小精灵不用精灵球
  for (int i = 1; i <= k; i++) {      //枚举考虑第i个小精灵
    for (int j = 0; j < m; j++) {     //花费了m体力
      for (int w = 0; w <= i; w++) {  //抓了i个小精灵
        int &t = f[(i) % 2][j][w];
        t = f[(i - 1) % 2][j][w];  //最少多少精灵球
        int nn = a[i].x, tt = a[i].y;
        if (j >= tt && w >= 1 && f[(i - 1) % 2][j - tt][w - 1] + nn <= n)
          t = min(t, f[(i - 1) % 2][j - tt][w - 1] + nn);
      }
    }
  }
  int c = 0, r = m;
  for (int i = 0; i < m; i++) {
    for (int j = 1; j <= k; j++) {
      if (f[(k) % 2][i][j] <= n) {
        if (c < j)
          r = m - i, c = j;
        else if (c == j)
          r = max(r, m - i);
      }
    }
  }

  cout << c << " " << r;
  return 0;
}
```

##### 数字组合

M看成是背包容量 每个数是一个物品 Ai是体积 总体积恰好是M的方案数

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220325153819418.png" alt="image-20220325153819418" style="zoom:80%;" />

```c++
//已知 有n个数 目标是和为n  求最大方案数
#include <bits/stdc++.h>
using namespace std;
const int N = 110, M = 10010;
int n, m, a[N], f[N][M];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) cin >> a[i];

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      int &x = f[i][j];
      x = f[i - 1][j];  //不用第i个数
      if (j > a[i])
        x += f[i - 1][j - a[i]];  //用第i个数
      else if(j==a[i])
        x += 1;
    }
  }
  cout << f[n][m];

  return 0;
}
```

##### 买书

完全背包问题 变成了方案数  需要把n元全部花完

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220325155312279.png" alt="image-20220325155312279" style="zoom:80%;" />

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[5]={0,10,20,50,100},n;
int f[2][N];
int main()
{
    cin >> n;
    f[0][0]=f[1][0]=1;
    for (int i = 1; i <= 4; i ++ ){
        for (int j = 0; j <= n; j ++ ){
            int &x=f[i%2][j];
            x=f[(i-1)%2][j];//不买第i本书
            if(j>a[i])x+=f[(i)%2][j-a[i]];
            else if(j==a[i])x+=1;
        }
    }
    cout<<f[4%2][n];
}
```

##### 货币系统

卡int了 n个物品 容量为m的背包 完全背包

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 20,M=3010;
LL n,m,a[N],f[2][M];
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ){//
        cin >> a[i];
    }
    f[0][0]=f[1][0]=1;
    for (int i = 1; i <= n; i ++ ){
        for (int j = 1; j <= m; j ++ ){
            LL &x=f[i%2][j];
            x=f[(i-1)%2][j];//不用第i个货币 组成j的方案
            if(j>=a[i])x+=f[(i)%2][j-a[i]];// 
        }
    }
    cout << f[n%2][m];
}
```

##### 货币系统（中等）

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220325232353785.png" alt="image-20220325232353785" style="zoom:80%;" />

将a1 a2 an从小到大排序 因为这里的系数非负 所以只能小数来表示大数

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110, M = 25010;
int a[N], f[2][M];
void solve() {
  memset(a, 0, sizeof a);
  memset(f, 0, sizeof f);
  int n;
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> a[i];
  sort(a + 1, a + n + 1);
  int m = a[n], res = 0;
  f[0][0] = f[1][0] = 1;
  for (int i = 1; i <= n; i++) {
    if (!f[(i - 1) % 2][a[i]]) res++;//如果前i个数不能表示 a[i]
    for (int j = 1; j <= m; j++) {
      int &x = f[i % 2][j];
      x = f[(i - 1) % 2][j];
      if (j >= a[i]) x |= f[i % 2][j - a[i]];
    }
  }
  cout << res << endl;
}
int main() {
  int t;
  cin >> t;
  for (int i = 1; i <= t; i++) {
    solve();
  }
  return 0;
}
```

##### 多重背包问题（单调队列优化）

传统推导

```c++
dp[i][j] 表示将前 i 种物品放入容量为 j 的背包中所得到的最大价值
dp[i][j] = max(不放入物品 i，放入1个物品 i，放入2个物品 i, ... , 放入k个物品 i)
这里 k 要满足：k <= s, j - k*v >= 0

不放物品  i = dp[i-1][j]
放k个物品 i = dp[i-1][j - k*v] + k*w

dp[i][j] = max(dp[i-1][j], dp[i-1][j-v] + w, dp[i-1][j-2*v] + 2*w,..., dp[i-1][j-k*v] + k*w)
```

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220326103237845.png" alt="image-20220326103237845" style="zoom:80%;" />

r是j 模v的余数

```c++
#pragma GCC optimize(3)
#pragma GCC optimize("inline")
#include <bits/stdc++.h>
using namespace std;
const int N = 20010;
int n, m;
int f[2][N];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    int v, w, s;
    cin >> v >> w >> s;          //每件体积是v 价值是w 数量是s
    for (int r = 0; r < v; r++)  // 体积除以v的余数
    {
      deque<int> Q;
      for (int k = r; k <= m; k += v)  //模v的 r的同余类
      {
        if (!Q.empty() && (k - Q.front()) / v > s) Q.pop_front(); // 是否超过了s个
        while (!Q.empty() &&
               f[(i - 1) % 2][Q.back()] - (Q.back() - r) / v * w <=
                   f[(i - 1) % 2][k] - (k - r) / v * w)
          Q.pop_back();
        Q.push_back(k);
        f[i % 2][k] = f[(i - 1) % 2][Q.front()] + (k - Q.front()) / v * w;
      }
    }
  }

  cout << f[n % 2][m] << endl;

  return 0;
}
```

##### 庆功会

多重背包

```c++
#include<bits/stdc++.h>
using namespace std;
const int M = 6010;
int n,m,f[2][M];
int main()
{
    cin >> n >>m;
    for (int i = 1; i <= n; i ++ ){
        int v,w,s;
        cin >> v>> w>> s;
        for (int r = 0; r < v; r ++ ){
            deque<int> Q;
            for (int j = r; j <= m; j +=v ){
                while(!Q.empty() && (j-Q.front())/v >s )Q.pop_front();
                while(!Q.empty() && f[(i-1)%2][Q.back()]-(Q.back()-r)/v*w <= 
                                    f[(i-1)%2][j]-(j-r)/v*w)Q.pop_back();
                Q.push_back(j);
                f[i%2][j]=f[(i-1)%2][Q.front()] + (j-Q.front())/v*w;
            }
        }
    }
    cout << f[n%2][m];
}
```

##### 混合背包问题

有三类物品 第一类只能用1次 第二类可以无限次，第三类可以si次

```c++
#include <bits/stdc++.h>
using namespace std;
const int V = 1010, INF = 0x3f3f3f3f;
int n, vv, f[2][V];
int main() {
  cin >> n >> vv;
  for (int i = 1; i <= n; i++) {
    int v, w, s;
    cin >> v >> w >> s;
    if (s == -1 || s == 0) {
      for (int j = 0; j <= vv; j++) {
        int &x = f[i % 2][j];
        x = f[(i - 1) % 2][j];
        if (s == -1) {
          if (j >= v) x = max(x, f[(i - 1) % 2][j - v] + w);
        }
        if (s == 0) {
          if (j >= v) x = max(x, f[(i) % 2][j - v] + w);
        }
      }
    } else {
      for (int r = 0; r < v; r++) {
        deque<int> Q;
        for (int j = r; j <= vv; j += v) {
          int &x = f[i % 2][j];
          x = f[(i - 1) % 2][j];
          while (!Q.empty() && (j - Q.front()) / v > s) Q.pop_front();
          while (!Q.empty() &&
                 f[(i - 1) % 2][Q.back()] - (Q.back() - r) / v * w <=
                     f[(i - 1) % 2][j] - (j - r) / v * w)
            Q.pop_back();
          Q.push_back(j);
          x = max(x, f[(i - 1) % 2][Q.front()] + (j - Q.front()) / v * w);
        }
      }
    }
  }

  cout << f[n % 2][vv];

  return 0;
}
```

##### 二维费用的背包问题

限制不只有体积 还有重量 也就是限制变成了二维的 

```c++
#include <bits/stdc++.h>
using namespace std;
const int V = 110, M = 110;
int n, v, m, f[2][V][M];
int main() {
  cin >> n >> v >> m;
  for (int i = 1; i <= n; ++i) {
    int vi, mi, wi;
    cin >> vi >> mi >> wi;
    for (int j = 0; j <= v; j++) {
      for (int k = 0; k <= m; k++) {
        int &x = f[i & 1][j][k];
        x = f[(i - 1) % 2][j][k];
        if (j >= vi && k >= mi) x = max(x, f[(i - 1) % 2][j - vi][k - mi] + wi);
      }
    }
  }
  cout << f[n % 2][v][m];
  return 0;
}
```

##### 潜水员

至多，恰好，至少 这三种状态转移方程都是一样的，
不同的是状态的定义域不同（前两者在负数上没有定义，后者有）和初始边界的不同了。

<img src="C:\Users\jshmj\AppData\Roaming\Typora\typora-user-images\image-20220326212543063.png" alt="image-20220326212543063" style="zoom:80%;" />

```c++
#include <bits/stdc++.h>
using namespace std;
const int M = 26, N = 89;
int m, n, k, f[2][M][N];
int main() {
  memset(f, 0x3f, sizeof f);
  cin >> m >> n >> k;
  f[0][0][0] = f[1][0][0] = 0;
  for (int i = 1; i <= k; i++) {
    int a, b, c;
    cin >> a >> b >> c;
    for (int j = 0; j <= m; j++) {    //氧气
      for (int w = 0; w <= n; w++) {  //氮气
        int &x = f[(i) % 2][j][w];
        x = f[(i - 1) % 2][j][w];
        x = min(x, f[(i - 1) % 2][max(0, j - a)][max(0, w - b)] + c);
      }
    }
  }
  cout << f[k % 2][m][n] << endl;
  return 0;
}
```



##### 机器分配

转化为分组背包问题 循环从外到内 是 分组数 体积大小 数目

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 15, M = 25;
int n, m, f[N][M], ww[N][M];
int way[N];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      int w;
      cin >> w;
      ww[i][j] = w;
      for (int k = 0; k <= m; k++) {
        int &x = f[i][k];
        x = max(x, f[(i - 1)][k]);
        if (k >= j) x = max(x, f[(i - 1)][k - j] + w);
      }
    }
  }

  cout << f[n][m] << endl;
  int left = m;  //剩余的机器数
  for (int i = n; i >= 1; i--) {
    for (int j = 0; j <= left; j++) {
      if (f[i][left] == f[i - 1][left - j] + ww[i][j]) {
        way[i] = j;
        left -= j;
        break;
      }
    }
  }
  for (int i = 1; i <= n; i++) cout << i << " " << way[i] << endl;
  return 0;
}
```

##### 开心的金明

01背包

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 3e4 + 5;
int n, m, f[2][N];
int main() {
  cin >> n >> m;
  for (int i = 1; i <= m; i++) {
    int v, p;
    cin >> v >> p;
    int w = v * p;
    for (int j = 0; j <= n; j++) {
      int &x = f[i % 2][j];
      x = f[(i - 1) % 2][j];
      if (j >= v) x = max(x, f[(i - 1) % 2][j - v] + w);
    }
  }
  cout << f[m % 2][n];
  return 0;
}
```

##### 有依赖的背包问题

转化为分组背包问题 一组是一颗子树 每一件物品是改子树的每一个体积的值

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
struct Edge {
  int to;
  Edge(int _to) { to = _to; }
};
vector<Edge> edges[N];
struct Thing {
  int v, w;
};
Thing things[N];
int n, v, f[N][N];

void dfs(int u) {
  int vv = things[u].v, ww = things[u].w;
  for (auto t : edges[u]) {//分组背包先 循环组数 再循环体积 再循环每组中的物品
    dfs(t.to);
    for (int j = v; j >= 0; j--) {//体积要从小到大
      for (int k = 0; k <= j; k++) {
        if (j >= k) f[u][j] = max(f[u][j], f[u][j - k] + f[t.to][k]);
      }
    }
  }//先考虑只选择子树
  for (int i = v; i >= vv; i--) f[u][i] = f[u][i - vv] + ww;//一定要选根
  for (int i = 0; i < vv; i++) f[u][i] = 0;
}

int main() {
  cin >> n >> v;
  int root;
  for (int i = 1; i <= n; i++) {
    int p;
    cin >> things[i].v >> things[i].w >> p;
    if (p == -1)
      root = i;
    else
      edges[p].emplace_back(i);
  }
  dfs(root);
  cout << f[root][v];
  return 0;
}
```

##### 背包问题求方案数



```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, mod = 1000000007;

int n, m;
int f[N], g[N];
int v[N], w[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];

    for (int i = 0; i <= m; i ++ ) g[i] = 1;

    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= v[i]; j -- )
        {
            int left = f[j], right = f[j - v[i]] + w[i];
            f[j] = max(left, right);

            if (left > right) g[j] = g[j];
            else if (left < right) g[j] = g[j - v[i]];
            else g[j] = g[j] + g[j - v[i]];
            g[j] %= mod;
        }

    cout << g[m] << endl;
    return 0;
}
```



### 杂题

##### 鸡蛋的硬度

如果鸡蛋个数无限 尝试的次数是logn 但是鸡蛋个数受限

条件 m个鸡蛋 n层楼

最优化 扔的次数 f[i] [j] i层楼 j个鸡蛋 仍的次数 或者 f[i] [j] 扔i次 j个鸡蛋 可以的层数

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=110,M=15,INF=0x3f3f3f3f;
int n,m,f[N][M];
int solve(int n,int m){//n是楼高 m是鸡蛋数
    if(f[n][m]!=-1)return f[n][m];
    if(n==0)return f[n][m]=n;
    if(m==1)return f[n][m]=n;
    int res = INF;
    for (int i = 1; i <= n; i ++ ){
        int rest=max(solve(i-1,m-1)+1,solve(n-i,m)+1);
        res=min(res,rest);
    }
    return f[n][m]=res;
}
int main()
{
    memset(f, -1, sizeof f);
    while(scanf("%d%d",&n,&m)==2){
        cout << solve(n,m)<<endl;
    }
}
```

f[i, j]表示用j个鸡蛋测量i次能测量的区间长度的最大值
枚举扔鸡蛋的楼层k，类似dp1，没碎测k楼以上，碎了测k楼以下，那么能测的最大高度就是上下两部分加上第k层楼这一层

```c++
#include <iostream>
using namespace std;

int f[110][15], n, m;

int main() {
    while (cin >> n >> m) {
        for (int i = 1; i <= n; i ++ ) {
            for (int j = 1; j <= m; j ++ )
                f[i][j] = f[i - 1][j] + f[i - 1][j - 1] + 1;
            if (f[i][m] >= n) {
                cout << i << endl;
                break;
            }
        }
    }
    return 0;
}
```

 
